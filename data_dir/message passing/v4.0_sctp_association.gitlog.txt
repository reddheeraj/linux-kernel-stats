commit 6fdfdef7fdb57e6b9f768c9ca0718dcb5e727a85
Author: Alexey Kodanev <aleksei.kodanev@bell-sw.com>
Date:   Wed Oct 19 21:07:33 2022 +0300

    sctp: remove unnecessary NULL check in sctp_association_init()
    
    '&asoc->ulpq' passed to sctp_ulpq_init() as the first argument,
    then sctp_qlpq_init() initializes it and eventually returns the
    address of the struct member back. Therefore, in this case, the
    return pointer cannot be NULL.
    
    Moreover, it seems sctp_ulpq_init() has always been used only in
    sctp_association_init(), so there's really no need to return ulpq
    anymore.
    
    Detected using the static analysis tool - Svace.
    Signed-off-by: Alexey Kodanev <aleksei.kodanev@bell-sw.com>
    Reviewed-by: Xin Long <lucien.xin@gmail.com>
    Link: https://lore.kernel.org/r/20221019180735.161388-1-aleksei.kodanev@bell-sw.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit d99f144acc3b4b27ab91f78fd6d7085385ccd654
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 25 18:11:06 2022 -0400

    sctp: leave the err path free in sctp_stream_init to sctp_stream_free
    
    [ Upstream commit 181d8d2066c000ba0a0e6940a7ad80f1a0e68e9d ]
    
    A NULL pointer dereference was reported by Wei Chen:
    
      BUG: kernel NULL pointer dereference, address: 0000000000000000
      RIP: 0010:__list_del_entry_valid+0x26/0x80
      Call Trace:
       <TASK>
       sctp_sched_dequeue_common+0x1c/0x90
       sctp_sched_prio_dequeue+0x67/0x80
       __sctp_outq_teardown+0x299/0x380
       sctp_outq_free+0x15/0x20
       sctp_association_free+0xc3/0x440
       sctp_do_sm+0x1ca7/0x2210
       sctp_assoc_bh_rcv+0x1f6/0x340
    
    This happens when calling sctp_sendmsg without connecting to server first.
    In this case, a data chunk already queues up in send queue of client side
    when processing the INIT_ACK from server in sctp_process_init() where it
    calls sctp_stream_init() to alloc stream_in. If it fails to alloc stream_in
    all stream_out will be freed in sctp_stream_init's err path. Then in the
    asoc freeing it will crash when dequeuing this data chunk as stream_out
    is missing.
    
    As we can't free stream out before dequeuing all data from send queue, and
    this patch is to fix it by moving the err path stream_out/in freeing in
    sctp_stream_init() to sctp_stream_free() which is eventually called when
    freeing the asoc in sctp_association_free(). This fix also makes the code
    in sctp_process_init() more clear.
    
    Note that in sctp_association_init() when it fails in sctp_stream_init(),
    sctp_association_free() will not be called, and in that case it should
    go to 'stream_free' err path to free stream instead of 'fail_init'.
    
    Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
    Reported-by: Wei Chen <harperchen1110@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Link: https://lore.kernel.org/r/831a3dc100c4908ff76e5bcc363be97f2778bc0b.1658787066.git.lucien.xin@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit e796e1fe20ecaf6da419ef6a5841ba181bba7a0c
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 25 18:11:06 2022 -0400

    sctp: leave the err path free in sctp_stream_init to sctp_stream_free
    
    [ Upstream commit 181d8d2066c000ba0a0e6940a7ad80f1a0e68e9d ]
    
    A NULL pointer dereference was reported by Wei Chen:
    
      BUG: kernel NULL pointer dereference, address: 0000000000000000
      RIP: 0010:__list_del_entry_valid+0x26/0x80
      Call Trace:
       <TASK>
       sctp_sched_dequeue_common+0x1c/0x90
       sctp_sched_prio_dequeue+0x67/0x80
       __sctp_outq_teardown+0x299/0x380
       sctp_outq_free+0x15/0x20
       sctp_association_free+0xc3/0x440
       sctp_do_sm+0x1ca7/0x2210
       sctp_assoc_bh_rcv+0x1f6/0x340
    
    This happens when calling sctp_sendmsg without connecting to server first.
    In this case, a data chunk already queues up in send queue of client side
    when processing the INIT_ACK from server in sctp_process_init() where it
    calls sctp_stream_init() to alloc stream_in. If it fails to alloc stream_in
    all stream_out will be freed in sctp_stream_init's err path. Then in the
    asoc freeing it will crash when dequeuing this data chunk as stream_out
    is missing.
    
    As we can't free stream out before dequeuing all data from send queue, and
    this patch is to fix it by moving the err path stream_out/in freeing in
    sctp_stream_init() to sctp_stream_free() which is eventually called when
    freeing the asoc in sctp_association_free(). This fix also makes the code
    in sctp_process_init() more clear.
    
    Note that in sctp_association_init() when it fails in sctp_stream_init(),
    sctp_association_free() will not be called, and in that case it should
    go to 'stream_free' err path to free stream instead of 'fail_init'.
    
    Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
    Reported-by: Wei Chen <harperchen1110@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Link: https://lore.kernel.org/r/831a3dc100c4908ff76e5bcc363be97f2778bc0b.1658787066.git.lucien.xin@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 6f3505588d66b27220f07d0cab18da380fae2e2d
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 25 18:11:06 2022 -0400

    sctp: leave the err path free in sctp_stream_init to sctp_stream_free
    
    [ Upstream commit 181d8d2066c000ba0a0e6940a7ad80f1a0e68e9d ]
    
    A NULL pointer dereference was reported by Wei Chen:
    
      BUG: kernel NULL pointer dereference, address: 0000000000000000
      RIP: 0010:__list_del_entry_valid+0x26/0x80
      Call Trace:
       <TASK>
       sctp_sched_dequeue_common+0x1c/0x90
       sctp_sched_prio_dequeue+0x67/0x80
       __sctp_outq_teardown+0x299/0x380
       sctp_outq_free+0x15/0x20
       sctp_association_free+0xc3/0x440
       sctp_do_sm+0x1ca7/0x2210
       sctp_assoc_bh_rcv+0x1f6/0x340
    
    This happens when calling sctp_sendmsg without connecting to server first.
    In this case, a data chunk already queues up in send queue of client side
    when processing the INIT_ACK from server in sctp_process_init() where it
    calls sctp_stream_init() to alloc stream_in. If it fails to alloc stream_in
    all stream_out will be freed in sctp_stream_init's err path. Then in the
    asoc freeing it will crash when dequeuing this data chunk as stream_out
    is missing.
    
    As we can't free stream out before dequeuing all data from send queue, and
    this patch is to fix it by moving the err path stream_out/in freeing in
    sctp_stream_init() to sctp_stream_free() which is eventually called when
    freeing the asoc in sctp_association_free(). This fix also makes the code
    in sctp_process_init() more clear.
    
    Note that in sctp_association_init() when it fails in sctp_stream_init(),
    sctp_association_free() will not be called, and in that case it should
    go to 'stream_free' err path to free stream instead of 'fail_init'.
    
    Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
    Reported-by: Wei Chen <harperchen1110@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Link: https://lore.kernel.org/r/831a3dc100c4908ff76e5bcc363be97f2778bc0b.1658787066.git.lucien.xin@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 8d6dab81ee3d0309c09987ff76164a25486c43e0
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 25 18:11:06 2022 -0400

    sctp: leave the err path free in sctp_stream_init to sctp_stream_free
    
    [ Upstream commit 181d8d2066c000ba0a0e6940a7ad80f1a0e68e9d ]
    
    A NULL pointer dereference was reported by Wei Chen:
    
      BUG: kernel NULL pointer dereference, address: 0000000000000000
      RIP: 0010:__list_del_entry_valid+0x26/0x80
      Call Trace:
       <TASK>
       sctp_sched_dequeue_common+0x1c/0x90
       sctp_sched_prio_dequeue+0x67/0x80
       __sctp_outq_teardown+0x299/0x380
       sctp_outq_free+0x15/0x20
       sctp_association_free+0xc3/0x440
       sctp_do_sm+0x1ca7/0x2210
       sctp_assoc_bh_rcv+0x1f6/0x340
    
    This happens when calling sctp_sendmsg without connecting to server first.
    In this case, a data chunk already queues up in send queue of client side
    when processing the INIT_ACK from server in sctp_process_init() where it
    calls sctp_stream_init() to alloc stream_in. If it fails to alloc stream_in
    all stream_out will be freed in sctp_stream_init's err path. Then in the
    asoc freeing it will crash when dequeuing this data chunk as stream_out
    is missing.
    
    As we can't free stream out before dequeuing all data from send queue, and
    this patch is to fix it by moving the err path stream_out/in freeing in
    sctp_stream_init() to sctp_stream_free() which is eventually called when
    freeing the asoc in sctp_association_free(). This fix also makes the code
    in sctp_process_init() more clear.
    
    Note that in sctp_association_init() when it fails in sctp_stream_init(),
    sctp_association_free() will not be called, and in that case it should
    go to 'stream_free' err path to free stream instead of 'fail_init'.
    
    Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
    Reported-by: Wei Chen <harperchen1110@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Link: https://lore.kernel.org/r/831a3dc100c4908ff76e5bcc363be97f2778bc0b.1658787066.git.lucien.xin@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 181d8d2066c000ba0a0e6940a7ad80f1a0e68e9d
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 25 18:11:06 2022 -0400

    sctp: leave the err path free in sctp_stream_init to sctp_stream_free
    
    A NULL pointer dereference was reported by Wei Chen:
    
      BUG: kernel NULL pointer dereference, address: 0000000000000000
      RIP: 0010:__list_del_entry_valid+0x26/0x80
      Call Trace:
       <TASK>
       sctp_sched_dequeue_common+0x1c/0x90
       sctp_sched_prio_dequeue+0x67/0x80
       __sctp_outq_teardown+0x299/0x380
       sctp_outq_free+0x15/0x20
       sctp_association_free+0xc3/0x440
       sctp_do_sm+0x1ca7/0x2210
       sctp_assoc_bh_rcv+0x1f6/0x340
    
    This happens when calling sctp_sendmsg without connecting to server first.
    In this case, a data chunk already queues up in send queue of client side
    when processing the INIT_ACK from server in sctp_process_init() where it
    calls sctp_stream_init() to alloc stream_in. If it fails to alloc stream_in
    all stream_out will be freed in sctp_stream_init's err path. Then in the
    asoc freeing it will crash when dequeuing this data chunk as stream_out
    is missing.
    
    As we can't free stream out before dequeuing all data from send queue, and
    this patch is to fix it by moving the err path stream_out/in freeing in
    sctp_stream_init() to sctp_stream_free() which is eventually called when
    freeing the asoc in sctp_association_free(). This fix also makes the code
    in sctp_process_init() more clear.
    
    Note that in sctp_association_init() when it fails in sctp_stream_init(),
    sctp_association_free() will not be called, and in that case it should
    go to 'stream_free' err path to free stream instead of 'fail_init'.
    
    Fixes: 5bbbbe32a431 ("sctp: introduce stream scheduler foundations")
    Reported-by: Wei Chen <harperchen1110@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Link: https://lore.kernel.org/r/831a3dc100c4908ff76e5bcc363be97f2778bc0b.1658787066.git.lucien.xin@gmail.com
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

commit 2bd080b0961d776f90e7b1ef9788c56da3638c73
Merge: 843c3cbbdf89 e7310c94024c
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Nov 3 11:09:21 2021 +0000

    Merge branch 'sctp-=security-hook-fixes'
    
    Xin Long says:
    
    ====================
    security: fixups for the security hooks in sctp
    
    There are a couple of problems in the currect security hooks in sctp:
    
    1. The hooks incorrectly treat sctp_endpoint in SCTP as request_sock in
       TCP, while it's in fact no more than an extension of the sock, and
       represents the local host. It is created when sock is created, not
       when a conn request comes. sctp_association is actually the correct
       one to represent the connection, and created when a conn request
       arrives.
    
    2. security_sctp_assoc_request() hook should also be called in processing
       COOKIE ECHO, as that's the place where the real assoc is created and
       used in the future.
    
    The problems above may cause accept sk, peeloff sk or client sk having
    the incorrect security labels.
    
    So this patchset is to change some hooks and pass asoc into them and save
    these secids into asoc, as well as add the missing sctp_assoc_request
    hook into the COOKIE ECHO processing.
    
    v1->v2:
      - See each patch, and thanks the help from Ondrej, Paul and Richard.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 95ceefc6f0ce47a68fcc01517d530b019d503b43
Author: Kevin Kou <qdkevin.kou@gmail.com>
Date:   Thu Dec 26 12:29:17 2019 +0000

    sctp: move trace_sctp_probe_path into sctp_outq_sack
    
    [ Upstream commit f643ee295c1c63bc117fb052d4da681354d6f732 ]
    
    The original patch bringed in the "SCTP ACK tracking trace event"
    feature was committed at Dec.20, 2017, it replaced jprobe usage
    with trace events, and bringed in two trace events, one is
    TRACE_EVENT(sctp_probe), another one is TRACE_EVENT(sctp_probe_path).
    The original patch intended to trigger the trace_sctp_probe_path in
    TRACE_EVENT(sctp_probe) as below code,
    
    +TRACE_EVENT(sctp_probe,
    +
    +       TP_PROTO(const struct sctp_endpoint *ep,
    +                const struct sctp_association *asoc,
    +                struct sctp_chunk *chunk),
    +
    +       TP_ARGS(ep, asoc, chunk),
    +
    +       TP_STRUCT__entry(
    +               __field(__u64, asoc)
    +               __field(__u32, mark)
    +               __field(__u16, bind_port)
    +               __field(__u16, peer_port)
    +               __field(__u32, pathmtu)
    +               __field(__u32, rwnd)
    +               __field(__u16, unack_data)
    +       ),
    +
    +       TP_fast_assign(
    +               struct sk_buff *skb = chunk->skb;
    +
    +               __entry->asoc = (unsigned long)asoc;
    +               __entry->mark = skb->mark;
    +               __entry->bind_port = ep->base.bind_addr.port;
    +               __entry->peer_port = asoc->peer.port;
    +               __entry->pathmtu = asoc->pathmtu;
    +               __entry->rwnd = asoc->peer.rwnd;
    +               __entry->unack_data = asoc->unack_data;
    +
    +               if (trace_sctp_probe_path_enabled()) {
    +                       struct sctp_transport *sp;
    +
    +                       list_for_each_entry(sp, &asoc->peer.transport_addr_list,
    +                                           transports) {
    +                               trace_sctp_probe_path(sp, asoc);
    +                       }
    +               }
    +       ),
    
    But I found it did not work when I did testing, and trace_sctp_probe_path
    had no output, I finally found that there is trace buffer lock
    operation(trace_event_buffer_reserve) in include/trace/trace_events.h:
    
    static notrace void                                                     \
    trace_event_raw_event_##call(void *__data, proto)                       \
    {                                                                       \
            struct trace_event_file *trace_file = __data;                   \
            struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\
            struct trace_event_buffer fbuffer;                              \
            struct trace_event_raw_##call *entry;                           \
            int __data_size;                                                \
                                                                            \
            if (trace_trigger_soft_disabled(trace_file))                    \
                    return;                                                 \
                                                                            \
            __data_size = trace_event_get_offsets_##call(&__data_offsets, args); \
                                                                            \
            entry = trace_event_buffer_reserve(&fbuffer, trace_file,        \
                                     sizeof(*entry) + __data_size);         \
                                                                            \
            if (!entry)                                                     \
                    return;                                                 \
                                                                            \
            tstruct                                                         \
                                                                            \
            { assign; }                                                     \
                                                                            \
            trace_event_buffer_commit(&fbuffer);                            \
    }
    
    The reason caused no output of trace_sctp_probe_path is that
    trace_sctp_probe_path written in TP_fast_assign part of
    TRACE_EVENT(sctp_probe), and it will be placed( { assign; } ) after the
    trace_event_buffer_reserve() when compiler expands Macro,
    
            entry = trace_event_buffer_reserve(&fbuffer, trace_file,        \
                                     sizeof(*entry) + __data_size);         \
                                                                            \
            if (!entry)                                                     \
                    return;                                                 \
                                                                            \
            tstruct                                                         \
                                                                            \
            { assign; }                                                     \
    
    so trace_sctp_probe_path finally can not acquire trace_event_buffer
    and return no output, that is to say the nest of tracepoint entry function
    is not allowed. The function call flow is:
    
    trace_sctp_probe()
    -> trace_event_raw_event_sctp_probe()
     -> lock buffer
     -> trace_sctp_probe_path()
       -> trace_event_raw_event_sctp_probe_path()  --nested
       -> buffer has been locked and return no output.
    
    This patch is to remove trace_sctp_probe_path from the TP_fast_assign
    part of TRACE_EVENT(sctp_probe) to avoid the nest of entry function,
    and trigger sctp_probe_path_trace in sctp_outq_sack.
    
    After this patch, you can enable both events individually,
      # cd /sys/kernel/debug/tracing
      # echo 1 > events/sctp/sctp_probe/enable
      # echo 1 > events/sctp/sctp_probe_path/enable
    
    Or, you can enable all the events under sctp.
    
      # echo 1 > events/sctp/enable
    
    Signed-off-by: Kevin Kou <qdkevin.kou@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 479468bef2fa4845cd894ad352181b619195fe70
Author: Kevin Kou <qdkevin.kou@gmail.com>
Date:   Thu Dec 26 12:29:17 2019 +0000

    sctp: move trace_sctp_probe_path into sctp_outq_sack
    
    [ Upstream commit f643ee295c1c63bc117fb052d4da681354d6f732 ]
    
    The original patch bringed in the "SCTP ACK tracking trace event"
    feature was committed at Dec.20, 2017, it replaced jprobe usage
    with trace events, and bringed in two trace events, one is
    TRACE_EVENT(sctp_probe), another one is TRACE_EVENT(sctp_probe_path).
    The original patch intended to trigger the trace_sctp_probe_path in
    TRACE_EVENT(sctp_probe) as below code,
    
    +TRACE_EVENT(sctp_probe,
    +
    +       TP_PROTO(const struct sctp_endpoint *ep,
    +                const struct sctp_association *asoc,
    +                struct sctp_chunk *chunk),
    +
    +       TP_ARGS(ep, asoc, chunk),
    +
    +       TP_STRUCT__entry(
    +               __field(__u64, asoc)
    +               __field(__u32, mark)
    +               __field(__u16, bind_port)
    +               __field(__u16, peer_port)
    +               __field(__u32, pathmtu)
    +               __field(__u32, rwnd)
    +               __field(__u16, unack_data)
    +       ),
    +
    +       TP_fast_assign(
    +               struct sk_buff *skb = chunk->skb;
    +
    +               __entry->asoc = (unsigned long)asoc;
    +               __entry->mark = skb->mark;
    +               __entry->bind_port = ep->base.bind_addr.port;
    +               __entry->peer_port = asoc->peer.port;
    +               __entry->pathmtu = asoc->pathmtu;
    +               __entry->rwnd = asoc->peer.rwnd;
    +               __entry->unack_data = asoc->unack_data;
    +
    +               if (trace_sctp_probe_path_enabled()) {
    +                       struct sctp_transport *sp;
    +
    +                       list_for_each_entry(sp, &asoc->peer.transport_addr_list,
    +                                           transports) {
    +                               trace_sctp_probe_path(sp, asoc);
    +                       }
    +               }
    +       ),
    
    But I found it did not work when I did testing, and trace_sctp_probe_path
    had no output, I finally found that there is trace buffer lock
    operation(trace_event_buffer_reserve) in include/trace/trace_events.h:
    
    static notrace void                                                     \
    trace_event_raw_event_##call(void *__data, proto)                       \
    {                                                                       \
            struct trace_event_file *trace_file = __data;                   \
            struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\
            struct trace_event_buffer fbuffer;                              \
            struct trace_event_raw_##call *entry;                           \
            int __data_size;                                                \
                                                                            \
            if (trace_trigger_soft_disabled(trace_file))                    \
                    return;                                                 \
                                                                            \
            __data_size = trace_event_get_offsets_##call(&__data_offsets, args); \
                                                                            \
            entry = trace_event_buffer_reserve(&fbuffer, trace_file,        \
                                     sizeof(*entry) + __data_size);         \
                                                                            \
            if (!entry)                                                     \
                    return;                                                 \
                                                                            \
            tstruct                                                         \
                                                                            \
            { assign; }                                                     \
                                                                            \
            trace_event_buffer_commit(&fbuffer);                            \
    }
    
    The reason caused no output of trace_sctp_probe_path is that
    trace_sctp_probe_path written in TP_fast_assign part of
    TRACE_EVENT(sctp_probe), and it will be placed( { assign; } ) after the
    trace_event_buffer_reserve() when compiler expands Macro,
    
            entry = trace_event_buffer_reserve(&fbuffer, trace_file,        \
                                     sizeof(*entry) + __data_size);         \
                                                                            \
            if (!entry)                                                     \
                    return;                                                 \
                                                                            \
            tstruct                                                         \
                                                                            \
            { assign; }                                                     \
    
    so trace_sctp_probe_path finally can not acquire trace_event_buffer
    and return no output, that is to say the nest of tracepoint entry function
    is not allowed. The function call flow is:
    
    trace_sctp_probe()
    -> trace_event_raw_event_sctp_probe()
     -> lock buffer
     -> trace_sctp_probe_path()
       -> trace_event_raw_event_sctp_probe_path()  --nested
       -> buffer has been locked and return no output.
    
    This patch is to remove trace_sctp_probe_path from the TP_fast_assign
    part of TRACE_EVENT(sctp_probe) to avoid the nest of entry function,
    and trigger sctp_probe_path_trace in sctp_outq_sack.
    
    After this patch, you can enable both events individually,
      # cd /sys/kernel/debug/tracing
      # echo 1 > events/sctp/sctp_probe/enable
      # echo 1 > events/sctp/sctp_probe_path/enable
    
    Or, you can enable all the events under sctp.
    
      # echo 1 > events/sctp/enable
    
    Signed-off-by: Kevin Kou <qdkevin.kou@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

commit 4dfb4833a549dfdf3b6771d722c08140fbe9c137
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    [ Upstream commit 245709ec8be89af46ea7ef0444c9c80913999d99 ]
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 548e23fcab6d8a777bbddc60d937faa893e4aba5
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    [ Upstream commit 245709ec8be89af46ea7ef0444c9c80913999d99 ]
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4fd5220a5c9e289fbb1079fcfd8320ee859c8aa8
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    [ Upstream commit 245709ec8be89af46ea7ef0444c9c80913999d99 ]
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 04f1991d9ca964cca75dd365d40486b4a37faa3a
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    [ Upstream commit 245709ec8be89af46ea7ef0444c9c80913999d99 ]
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c360e0530107ebf7423222c54f13b07e8c0283da
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    [ Upstream commit 245709ec8be89af46ea7ef0444c9c80913999d99 ]
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 487317df3e2e74edcb9ff05e7186b1a14f3bca30
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    [ Upstream commit 245709ec8be89af46ea7ef0444c9c80913999d99 ]
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 245709ec8be89af46ea7ef0444c9c80913999d99
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Feb 18 12:07:53 2020 +0800

    sctp: move the format error check out of __sctp_sf_do_9_1_abort
    
    When T2 timer is to be stopped, the asoc should also be deleted,
    otherwise, there will be no chance to call sctp_association_free
    and the asoc could last in memory forever.
    
    However, in sctp_sf_shutdown_sent_abort(), after adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer, it may return error due to the
    format error from __sctp_sf_do_9_1_abort() and miss adding
    SCTP_CMD_ASSOC_FAILED where the asoc will be deleted.
    
    This patch is to fix it by moving the format error check out of
    __sctp_sf_do_9_1_abort(), and do it before adding the cmd
    SCTP_CMD_TIMER_STOP for T2 timer.
    
    Thanks Hangbin for reporting this issue by the fuzz testing.
    
    v1->v2:
      - improve the comment in the code as Marcelo's suggestion.
    
    Fixes: 96ca468b86b0 ("sctp: check invalid value of length parameter in error cause")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f643ee295c1c63bc117fb052d4da681354d6f732
Author: Kevin Kou <qdkevin.kou@gmail.com>
Date:   Thu Dec 26 12:29:17 2019 +0000

    sctp: move trace_sctp_probe_path into sctp_outq_sack
    
    The original patch bringed in the "SCTP ACK tracking trace event"
    feature was committed at Dec.20, 2017, it replaced jprobe usage
    with trace events, and bringed in two trace events, one is
    TRACE_EVENT(sctp_probe), another one is TRACE_EVENT(sctp_probe_path).
    The original patch intended to trigger the trace_sctp_probe_path in
    TRACE_EVENT(sctp_probe) as below code,
    
    +TRACE_EVENT(sctp_probe,
    +
    +       TP_PROTO(const struct sctp_endpoint *ep,
    +                const struct sctp_association *asoc,
    +                struct sctp_chunk *chunk),
    +
    +       TP_ARGS(ep, asoc, chunk),
    +
    +       TP_STRUCT__entry(
    +               __field(__u64, asoc)
    +               __field(__u32, mark)
    +               __field(__u16, bind_port)
    +               __field(__u16, peer_port)
    +               __field(__u32, pathmtu)
    +               __field(__u32, rwnd)
    +               __field(__u16, unack_data)
    +       ),
    +
    +       TP_fast_assign(
    +               struct sk_buff *skb = chunk->skb;
    +
    +               __entry->asoc = (unsigned long)asoc;
    +               __entry->mark = skb->mark;
    +               __entry->bind_port = ep->base.bind_addr.port;
    +               __entry->peer_port = asoc->peer.port;
    +               __entry->pathmtu = asoc->pathmtu;
    +               __entry->rwnd = asoc->peer.rwnd;
    +               __entry->unack_data = asoc->unack_data;
    +
    +               if (trace_sctp_probe_path_enabled()) {
    +                       struct sctp_transport *sp;
    +
    +                       list_for_each_entry(sp, &asoc->peer.transport_addr_list,
    +                                           transports) {
    +                               trace_sctp_probe_path(sp, asoc);
    +                       }
    +               }
    +       ),
    
    But I found it did not work when I did testing, and trace_sctp_probe_path
    had no output, I finally found that there is trace buffer lock
    operation(trace_event_buffer_reserve) in include/trace/trace_events.h:
    
    static notrace void                                                     \
    trace_event_raw_event_##call(void *__data, proto)                       \
    {                                                                       \
            struct trace_event_file *trace_file = __data;                   \
            struct trace_event_data_offsets_##call __maybe_unused __data_offsets;\
            struct trace_event_buffer fbuffer;                              \
            struct trace_event_raw_##call *entry;                           \
            int __data_size;                                                \
                                                                            \
            if (trace_trigger_soft_disabled(trace_file))                    \
                    return;                                                 \
                                                                            \
            __data_size = trace_event_get_offsets_##call(&__data_offsets, args); \
                                                                            \
            entry = trace_event_buffer_reserve(&fbuffer, trace_file,        \
                                     sizeof(*entry) + __data_size);         \
                                                                            \
            if (!entry)                                                     \
                    return;                                                 \
                                                                            \
            tstruct                                                         \
                                                                            \
            { assign; }                                                     \
                                                                            \
            trace_event_buffer_commit(&fbuffer);                            \
    }
    
    The reason caused no output of trace_sctp_probe_path is that
    trace_sctp_probe_path written in TP_fast_assign part of
    TRACE_EVENT(sctp_probe), and it will be placed( { assign; } ) after the
    trace_event_buffer_reserve() when compiler expands Macro,
    
            entry = trace_event_buffer_reserve(&fbuffer, trace_file,        \
                                     sizeof(*entry) + __data_size);         \
                                                                            \
            if (!entry)                                                     \
                    return;                                                 \
                                                                            \
            tstruct                                                         \
                                                                            \
            { assign; }                                                     \
    
    so trace_sctp_probe_path finally can not acquire trace_event_buffer
    and return no output, that is to say the nest of tracepoint entry function
    is not allowed. The function call flow is:
    
    trace_sctp_probe()
    -> trace_event_raw_event_sctp_probe()
     -> lock buffer
     -> trace_sctp_probe_path()
       -> trace_event_raw_event_sctp_probe_path()  --nested
       -> buffer has been locked and return no output.
    
    This patch is to remove trace_sctp_probe_path from the TP_fast_assign
    part of TRACE_EVENT(sctp_probe) to avoid the nest of entry function,
    and trigger sctp_probe_path_trace in sctp_outq_sack.
    
    After this patch, you can enable both events individually,
      # cd /sys/kernel/debug/tracing
      # echo 1 > events/sctp/sctp_probe/enable
      # echo 1 > events/sctp/sctp_probe_path/enable
    
    Or, you can enable all the events under sctp.
    
      # echo 1 > events/sctp/enable
    
    Signed-off-by: Kevin Kou <qdkevin.kou@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 681e08498e5e7e051ba1fedf815509f56ef31c4f
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Fri Nov 22 16:17:56 2019 -0600

    sctp: Fix memory leak in sctp_sf_do_5_2_4_dupcook
    
    [ Upstream commit b6631c6031c746ed004c4221ec0616d7a520f441 ]
    
    In the implementation of sctp_sf_do_5_2_4_dupcook() the allocated
    new_asoc is leaked if security_sctp_assoc_request() fails. Release it
    via sctp_association_free().
    
    Fixes: 2277c7cd75e3 ("sctp: Add LSM hooks")
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 158bf62a492af802141dd388b599a9f4566d5390
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Fri Nov 22 16:17:56 2019 -0600

    sctp: Fix memory leak in sctp_sf_do_5_2_4_dupcook
    
    [ Upstream commit b6631c6031c746ed004c4221ec0616d7a520f441 ]
    
    In the implementation of sctp_sf_do_5_2_4_dupcook() the allocated
    new_asoc is leaked if security_sctp_assoc_request() fails. Release it
    via sctp_association_free().
    
    Fixes: 2277c7cd75e3 ("sctp: Add LSM hooks")
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d6a456237de1380c724a504f7105aad9a3e65873
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Fri Nov 22 16:17:56 2019 -0600

    sctp: Fix memory leak in sctp_sf_do_5_2_4_dupcook
    
    [ Upstream commit b6631c6031c746ed004c4221ec0616d7a520f441 ]
    
    In the implementation of sctp_sf_do_5_2_4_dupcook() the allocated
    new_asoc is leaked if security_sctp_assoc_request() fails. Release it
    via sctp_association_free().
    
    Fixes: 2277c7cd75e3 ("sctp: Add LSM hooks")
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b6631c6031c746ed004c4221ec0616d7a520f441
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Fri Nov 22 16:17:56 2019 -0600

    sctp: Fix memory leak in sctp_sf_do_5_2_4_dupcook
    
    In the implementation of sctp_sf_do_5_2_4_dupcook() the allocated
    new_asoc is leaked if security_sctp_assoc_request() fails. Release it
    via sctp_association_free().
    
    Fixes: 2277c7cd75e3 ("sctp: Add LSM hooks")
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

commit bb2ded26028be00204dbe2153f98fbd1902a2187
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Aug 19 22:02:44 2019 +0800

    sctp: not set peer.asconf_capable in sctp_association_init
    
    asoc->peer.asconf_capable is to be set during handshake, and its
    value should be initialized to 0. net->sctp.addip_noauth will be
    checked in sctp_process_init when processing INIT_ACK on client
    and COOKIE_ECHO on server.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a275c66b4d81ba9284bea79a125018a1cbe70db1
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Nov 27 19:11:50 2018 +0800

    sctp: update frag_point when stream_interleave is set
    
    [ Upstream commit 4135cce7fd0a0d755665c02728578c7c5afe4726 ]
    
    sctp_assoc_update_frag_point() should be called whenever asoc->pathmtu
    changes, but we missed one place in sctp_association_init(). It would
    cause frag_point is zero when sending data.
    
    As says in Jakub's reproducer, if sp->pathmtu is set by socketopt, the
    new asoc->pathmtu inherits it in sctp_association_init(). Later when
    transports are added and their pmtu >= asoc->pathmtu, it will never
    call sctp_assoc_update_frag_point() to set frag_point.
    
    This patch is to fix it by updating frag_point after asoc->pathmtu is
    set as sp->pathmtu in sctp_association_init(). Note that it moved them
    after sctp_stream_init(), as stream->si needs to be set first.
    
    Frag_point's calculation is also related with datachunk's type, so it
    needs to update frag_point when stream->si may be changed in
    sctp_process_init().
    
    v1->v2:
      - call sctp_assoc_update_frag_point() separately in sctp_process_init
        and sctp_association_init, per Marcelo's suggestion.
    
    Fixes: 2f5e3c9df693 ("sctp: introduce sctp_assoc_update_frag_point")
    Reported-by: Jakub Audykowicz <jakub.audykowicz@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4135cce7fd0a0d755665c02728578c7c5afe4726
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Nov 27 19:11:50 2018 +0800

    sctp: update frag_point when stream_interleave is set
    
    sctp_assoc_update_frag_point() should be called whenever asoc->pathmtu
    changes, but we missed one place in sctp_association_init(). It would
    cause frag_point is zero when sending data.
    
    As says in Jakub's reproducer, if sp->pathmtu is set by socketopt, the
    new asoc->pathmtu inherits it in sctp_association_init(). Later when
    transports are added and their pmtu >= asoc->pathmtu, it will never
    call sctp_assoc_update_frag_point() to set frag_point.
    
    This patch is to fix it by updating frag_point after asoc->pathmtu is
    set as sp->pathmtu in sctp_association_init(). Note that it moved them
    after sctp_stream_init(), as stream->si needs to be set first.
    
    Frag_point's calculation is also related with datachunk's type, so it
    needs to update frag_point when stream->si may be changed in
    sctp_process_init().
    
    v1->v2:
      - call sctp_assoc_update_frag_point() separately in sctp_process_init
        and sctp_association_init, per Marcelo's suggestion.
    
    Fixes: 2f5e3c9df693 ("sctp: introduce sctp_assoc_update_frag_point")
    Reported-by: Jakub Audykowicz <jakub.audykowicz@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1b0bb7e515b2292da2be1286b994ad1cf1096af3
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 16 15:18:17 2018 -0300

    sctp: fix race on sctp_id2asoc
    
    [ Upstream commit b336decab22158937975293aea79396525f92bb3 ]
    
    syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov
    helped to root cause it and it is because of reading the asoc after it
    was freed:
    
            CPU 1                       CPU 2
    (working on socket 1)            (working on socket 2)
                                     sctp_association_destroy
    sctp_id2asoc
       spin lock
         grab the asoc from idr
       spin unlock
                                       spin lock
                                         remove asoc from idr
                                       spin unlock
                                       free(asoc)
       if asoc->base.sk != sk ... [*]
    
    This can only be hit if trying to fetch asocs from different sockets. As
    we have a single IDR for all asocs, in all SCTP sockets, their id is
    unique on the system. An application can try to send stuff on an id
    that matches on another socket, and the if in [*] will protect from such
    usage. But it didn't consider that as that asoc may belong to another
    socket, it may be freed in parallel (read: under another socket lock).
    
    We fix it by moving the checks in [*] into the protected region. This
    fixes it because the asoc cannot be freed while the lock is held.
    
    Reported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fee37f15abcc273766186e13c2ff0338f14035cd
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 16 15:18:17 2018 -0300

    sctp: fix race on sctp_id2asoc
    
    [ Upstream commit b336decab22158937975293aea79396525f92bb3 ]
    
    syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov
    helped to root cause it and it is because of reading the asoc after it
    was freed:
    
            CPU 1                       CPU 2
    (working on socket 1)            (working on socket 2)
                                     sctp_association_destroy
    sctp_id2asoc
       spin lock
         grab the asoc from idr
       spin unlock
                                       spin lock
                                         remove asoc from idr
                                       spin unlock
                                       free(asoc)
       if asoc->base.sk != sk ... [*]
    
    This can only be hit if trying to fetch asocs from different sockets. As
    we have a single IDR for all asocs, in all SCTP sockets, their id is
    unique on the system. An application can try to send stuff on an id
    that matches on another socket, and the if in [*] will protect from such
    usage. But it didn't consider that as that asoc may belong to another
    socket, it may be freed in parallel (read: under another socket lock).
    
    We fix it by moving the checks in [*] into the protected region. This
    fixes it because the asoc cannot be freed while the lock is held.
    
    Reported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 55eb3e7e4f3000896abbf9955cbb0757e585b16d
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 16 15:18:17 2018 -0300

    sctp: fix race on sctp_id2asoc
    
    [ Upstream commit b336decab22158937975293aea79396525f92bb3 ]
    
    syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov
    helped to root cause it and it is because of reading the asoc after it
    was freed:
    
            CPU 1                       CPU 2
    (working on socket 1)            (working on socket 2)
                                     sctp_association_destroy
    sctp_id2asoc
       spin lock
         grab the asoc from idr
       spin unlock
                                       spin lock
                                         remove asoc from idr
                                       spin unlock
                                       free(asoc)
       if asoc->base.sk != sk ... [*]
    
    This can only be hit if trying to fetch asocs from different sockets. As
    we have a single IDR for all asocs, in all SCTP sockets, their id is
    unique on the system. An application can try to send stuff on an id
    that matches on another socket, and the if in [*] will protect from such
    usage. But it didn't consider that as that asoc may belong to another
    socket, it may be freed in parallel (read: under another socket lock).
    
    We fix it by moving the checks in [*] into the protected region. This
    fixes it because the asoc cannot be freed while the lock is held.
    
    Reported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 606694e5ec81d598c0300f9e16db0464659df557
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 16 15:18:17 2018 -0300

    sctp: fix race on sctp_id2asoc
    
    [ Upstream commit b336decab22158937975293aea79396525f92bb3 ]
    
    syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov
    helped to root cause it and it is because of reading the asoc after it
    was freed:
    
            CPU 1                       CPU 2
    (working on socket 1)            (working on socket 2)
                                     sctp_association_destroy
    sctp_id2asoc
       spin lock
         grab the asoc from idr
       spin unlock
                                       spin lock
                                         remove asoc from idr
                                       spin unlock
                                       free(asoc)
       if asoc->base.sk != sk ... [*]
    
    This can only be hit if trying to fetch asocs from different sockets. As
    we have a single IDR for all asocs, in all SCTP sockets, their id is
    unique on the system. An application can try to send stuff on an id
    that matches on another socket, and the if in [*] will protect from such
    usage. But it didn't consider that as that asoc may belong to another
    socket, it may be freed in parallel (read: under another socket lock).
    
    We fix it by moving the checks in [*] into the protected region. This
    fixes it because the asoc cannot be freed while the lock is held.
    
    Reported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 63f8939f793bc4214a9c436bffa1d390cd6fdc9b
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Oct 17 03:06:12 2018 +0800

    sctp: not free the new asoc when sctp_wait_for_connect returns err
    
    [ Upstream commit c863850ce22e1b0bb365d49cadf51f4765153ae4 ]
    
    When sctp_wait_for_connect is called to wait for connect ready
    for sp->strm_interleave in sctp_sendmsg_to_asoc, a panic could
    be triggered if cpu is scheduled out and the new asoc is freed
    elsewhere, as it will return err and later the asoc gets freed
    again in sctp_sendmsg.
    
    [  285.840764] list_del corruption, ffff9f0f7b284078->next is LIST_POISON1 (dead000000000100)
    [  285.843590] WARNING: CPU: 1 PID: 8861 at lib/list_debug.c:47 __list_del_entry_valid+0x50/0xa0
    [  285.846193] Kernel panic - not syncing: panic_on_warn set ...
    [  285.846193]
    [  285.848206] CPU: 1 PID: 8861 Comm: sctp_ndata Kdump: loaded Not tainted 4.19.0-rc7.label #584
    [  285.850559] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011
    [  285.852164] Call Trace:
    ...
    [  285.872210]  ? __list_del_entry_valid+0x50/0xa0
    [  285.872894]  sctp_association_free+0x42/0x2d0 [sctp]
    [  285.873612]  sctp_sendmsg+0x5a4/0x6b0 [sctp]
    [  285.874236]  sock_sendmsg+0x30/0x40
    [  285.874741]  ___sys_sendmsg+0x27a/0x290
    [  285.875304]  ? __switch_to_asm+0x34/0x70
    [  285.875872]  ? __switch_to_asm+0x40/0x70
    [  285.876438]  ? ptep_set_access_flags+0x2a/0x30
    [  285.877083]  ? do_wp_page+0x151/0x540
    [  285.877614]  __sys_sendmsg+0x58/0xa0
    [  285.878138]  do_syscall_64+0x55/0x180
    [  285.878669]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    This is a similar issue with the one fixed in Commit ca3af4dd28cf
    ("sctp: do not free asoc when it is already dead in sctp_sendmsg").
    But this one can't be fixed by returning -ESRCH for the dead asoc
    in sctp_wait_for_connect, as it will break sctp_connect's return
    value to users.
    
    This patch is to simply set err to -ESRCH before it returns to
    sctp_sendmsg when any err is returned by sctp_wait_for_connect
    for sp->strm_interleave, so that no asoc would be freed due to
    this.
    
    When users see this error, they will know the packet hasn't been
    sent. And it also makes sense to not free asoc because waiting
    connect fails, like the second call for sctp_wait_for_connect in
    sctp_sendmsg_to_asoc.
    
    Fixes: 668c9beb9020 ("sctp: implement assign_number for sctp_stream_interleave")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 721933262ef72a24595598ad6d20e98fc1b1ab82
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 16 15:18:17 2018 -0300

    sctp: fix race on sctp_id2asoc
    
    [ Upstream commit b336decab22158937975293aea79396525f92bb3 ]
    
    syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov
    helped to root cause it and it is because of reading the asoc after it
    was freed:
    
            CPU 1                       CPU 2
    (working on socket 1)            (working on socket 2)
                                     sctp_association_destroy
    sctp_id2asoc
       spin lock
         grab the asoc from idr
       spin unlock
                                       spin lock
                                         remove asoc from idr
                                       spin unlock
                                       free(asoc)
       if asoc->base.sk != sk ... [*]
    
    This can only be hit if trying to fetch asocs from different sockets. As
    we have a single IDR for all asocs, in all SCTP sockets, their id is
    unique on the system. An application can try to send stuff on an id
    that matches on another socket, and the if in [*] will protect from such
    usage. But it didn't consider that as that asoc may belong to another
    socket, it may be freed in parallel (read: under another socket lock).
    
    We fix it by moving the checks in [*] into the protected region. This
    fixes it because the asoc cannot be freed while the lock is held.
    
    Reported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c863850ce22e1b0bb365d49cadf51f4765153ae4
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Oct 17 03:06:12 2018 +0800

    sctp: not free the new asoc when sctp_wait_for_connect returns err
    
    When sctp_wait_for_connect is called to wait for connect ready
    for sp->strm_interleave in sctp_sendmsg_to_asoc, a panic could
    be triggered if cpu is scheduled out and the new asoc is freed
    elsewhere, as it will return err and later the asoc gets freed
    again in sctp_sendmsg.
    
    [  285.840764] list_del corruption, ffff9f0f7b284078->next is LIST_POISON1 (dead000000000100)
    [  285.843590] WARNING: CPU: 1 PID: 8861 at lib/list_debug.c:47 __list_del_entry_valid+0x50/0xa0
    [  285.846193] Kernel panic - not syncing: panic_on_warn set ...
    [  285.846193]
    [  285.848206] CPU: 1 PID: 8861 Comm: sctp_ndata Kdump: loaded Not tainted 4.19.0-rc7.label #584
    [  285.850559] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011
    [  285.852164] Call Trace:
    ...
    [  285.872210]  ? __list_del_entry_valid+0x50/0xa0
    [  285.872894]  sctp_association_free+0x42/0x2d0 [sctp]
    [  285.873612]  sctp_sendmsg+0x5a4/0x6b0 [sctp]
    [  285.874236]  sock_sendmsg+0x30/0x40
    [  285.874741]  ___sys_sendmsg+0x27a/0x290
    [  285.875304]  ? __switch_to_asm+0x34/0x70
    [  285.875872]  ? __switch_to_asm+0x40/0x70
    [  285.876438]  ? ptep_set_access_flags+0x2a/0x30
    [  285.877083]  ? do_wp_page+0x151/0x540
    [  285.877614]  __sys_sendmsg+0x58/0xa0
    [  285.878138]  do_syscall_64+0x55/0x180
    [  285.878669]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    This is a similar issue with the one fixed in Commit ca3af4dd28cf
    ("sctp: do not free asoc when it is already dead in sctp_sendmsg").
    But this one can't be fixed by returning -ESRCH for the dead asoc
    in sctp_wait_for_connect, as it will break sctp_connect's return
    value to users.
    
    This patch is to simply set err to -ESRCH before it returns to
    sctp_sendmsg when any err is returned by sctp_wait_for_connect
    for sp->strm_interleave, so that no asoc would be freed due to
    this.
    
    When users see this error, they will know the packet hasn't been
    sent. And it also makes sense to not free asoc because waiting
    connect fails, like the second call for sctp_wait_for_connect in
    sctp_sendmsg_to_asoc.
    
    Fixes: 668c9beb9020 ("sctp: implement assign_number for sctp_stream_interleave")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b336decab22158937975293aea79396525f92bb3
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 16 15:18:17 2018 -0300

    sctp: fix race on sctp_id2asoc
    
    syzbot reported an use-after-free involving sctp_id2asoc.  Dmitry Vyukov
    helped to root cause it and it is because of reading the asoc after it
    was freed:
    
            CPU 1                       CPU 2
    (working on socket 1)            (working on socket 2)
                                     sctp_association_destroy
    sctp_id2asoc
       spin lock
         grab the asoc from idr
       spin unlock
                                       spin lock
                                         remove asoc from idr
                                       spin unlock
                                       free(asoc)
       if asoc->base.sk != sk ... [*]
    
    This can only be hit if trying to fetch asocs from different sockets. As
    we have a single IDR for all asocs, in all SCTP sockets, their id is
    unique on the system. An application can try to send stuff on an id
    that matches on another socket, and the if in [*] will protect from such
    usage. But it didn't consider that as that asoc may belong to another
    socket, it may be freed in parallel (read: under another socket lock).
    
    We fix it by moving the checks in [*] into the protected region. This
    fixes it because the asoc cannot be freed while the lock is held.
    
    Reported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0aee4c259849099cb07ead6cd7fff74e561d5225
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Mon Mar 12 14:15:25 2018 -0400

    sctp: Fix double free in sctp_sendmsg_to_asoc
    
    syzbot/kasan detected a double free in sctp_sendmsg_to_asoc:
    BUG: KASAN: use-after-free in sctp_association_free+0x7b7/0x930
    net/sctp/associola.c:332
    Read of size 8 at addr ffff8801d8006ae0 by task syzkaller914861/4202
    
    CPU: 1 PID: 4202 Comm: syzkaller914861 Not tainted 4.16.0-rc4+ #258
    Hardware name: Google Google Compute Engine/Google Compute Engine
    01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:17 [inline]
     dump_stack+0x194/0x24d lib/dump_stack.c:53
     print_address_description+0x73/0x250 mm/kasan/report.c:256
     kasan_report_error mm/kasan/report.c:354 [inline]
     kasan_report+0x23c/0x360 mm/kasan/report.c:412
     __asan_report_load8_noabort+0x14/0x20 mm/kasan/report.c:433
     sctp_association_free+0x7b7/0x930 net/sctp/associola.c:332
     sctp_sendmsg+0xc67/0x1a80 net/sctp/socket.c:2075
     inet_sendmsg+0x11f/0x5e0 net/ipv4/af_inet.c:763
     sock_sendmsg_nosec net/socket.c:629 [inline]
     sock_sendmsg+0xca/0x110 net/socket.c:639
     SYSC_sendto+0x361/0x5c0 net/socket.c:1748
     SyS_sendto+0x40/0x50 net/socket.c:1716
     do_syscall_64+0x281/0x940 arch/x86/entry/common.c:287
     entry_SYSCALL_64_after_hwframe+0x42/0xb7
    
    This was introduced by commit:
    f84af33 sctp: factor out sctp_sendmsg_to_asoc from sctp_sendmsg
    
    As the newly refactored function moved the wait_for_sndbuf call to a
    point after the association was connected, allowing for peeloff events
    to occur, which in turn caused wait_for_sndbuf to return -EPIPE which
    was not caught by the logic that determines if an association should be
    freed or not.
    
    Fix it the easy way by returning the ordering of
    sctp_primitive_ASSOCIATE and sctp_wait_for_sndbuf to the old order, to
    ensure that EPIPE will not happen.
    
    Tested by myself using the syzbot reproducers with positive results
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: davem@davemloft.net
    CC: Xin Long <lucien.xin@gmail.com>
    Reported-by: syzbot+a4e4112c3aff00c8cfd8@syzkaller.appspotmail.com
    Reviewed-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e871cae7927ba5d86508066a5f4bec0ea1d7eb95
Merge: e4e31cf07d0c 0a3920d28b54
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Mar 4 13:00:58 2018 -0500

    Merge branch 'sctp-clean-up-sctp_sendmsg'
    
    Xin Long says:
    
    ====================
    sctp: clean up sctp_sendmsg
    
    This cleanup mostly does three things:
    
     - extract some codes into functions to make sendmsg more readable.
    
     - tidy up some codes to avoid the unnecessary checks.
    
     - adjust some logic so that it will be easier to add the send flags
       and cmsgs features that I will post after this.
    
    To make it easy to review and to check if the code is compatible with
    before, this patchset is to do it step by step in 9 patches.
    
    NOTE:
    There will be a conflict when merging
    Commit 2277c7cd75e3 ("sctp: Add LSM hooks") from selinux tree,
    the solution is to:
    
    1. remove all the lines in [B]:
    
        <<<<<<< HEAD
        [A]
        =======
        [B]
        >>>>>>> 2277c7c... sctp: Add LSM hooks
    
    2. and apply the following diff-output:
    
    diff --git a/net/sctp/socket.c b/net/sctp/socket.c
    index 980621e..d6803c8 100644
    --- a/net/sctp/socket.c
    +++ b/net/sctp/socket.c
    @@ -1686,6 +1686,7 @@ static int sctp_sendmsg_new_asoc(struct sock *sk, __u16 sflags,
            struct net *net = sock_net(sk);
            struct sctp_association *asoc;
            enum sctp_scope scope;
    +       struct sctp_af *af;
            int err = -EINVAL;
    
            *tp = NULL;
    @@ -1711,6 +1712,22 @@ static int sctp_sendmsg_new_asoc(struct sock *sk, __u16 sflags,
    
            scope = sctp_scope(daddr);
    
    +       /* Label connection socket for first association 1-to-many
    +        * style for client sequence socket()->sendmsg(). This
    +        * needs to be done before sctp_assoc_add_peer() as that will
    +        * set up the initial packet that needs to account for any
    +        * security ip options (CIPSO/CALIPSO) added to the packet.
    +        */
    +       af = sctp_get_af_specific(daddr->sa.sa_family);
    +       if (!af)
    +               return -EINVAL;
    +
    +       err = security_sctp_bind_connect(sk, SCTP_SENDMSG_CONNECT,
    +                                        (struct sockaddr *)daddr,
    +                                        af->sockaddr_len);
    +       if (err < 0)
    +               return err;
    +
            asoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);
            if (!asoc)
                    return -ENOMEM;
    ====================
    
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 581947787eaf1ad801959d00b42b9d0131aacb6a
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Mar 20 18:00:28 2017 +0800

    sctp: remove useless err from sctp_association_init
    
    This patch is to remove the unnecessary temporary variable 'err' from
    sctp_association_init.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 715f5552b1e90ba3eecf6d1a6d044d0d5226663f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Sep 10 23:11:23 2016 +0800

    sctp: hold the transport before using it in sctp_hash_cmp
    
    Since commit 4f0087812648 ("sctp: apply rhashtable api to send/recv
    path"), sctp uses transport rhashtable with .obj_cmpfn sctp_hash_cmp,
    in which it compares the members of the transport with the rhashtable
    args to check if it's the right transport.
    
    But sctp uses the transport without holding it in sctp_hash_cmp, it can
    cause a use-after-free panic. As after it gets transport from hashtable,
    another CPU may close the sk and free the asoc. In sctp_association_free,
    it frees all the transports, meanwhile, the assoc's refcnt may be reduced
    to 0, assoc can be destroyed by sctp_association_destroy.
    
    So after that, transport->assoc is actually an unavailable memory address
    in sctp_hash_cmp. Although sctp_hash_cmp is under rcu_read_lock, it still
    can not avoid this, as assoc is not freed by RCU.
    
    This patch is to hold the transport before checking it's members with
    sctp_transport_hold, in which it checks the refcnt first, holds it if
    it's not 0.
    
    Fixes: 4f0087812648 ("sctp: apply rhashtable api to send/recv path")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1b9143bddfef9047efcfc4627014a20a7c8c743f
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    commit 600ddd6825543962fb807884169e57b580dba208 upstream
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 0565f4368ff26e2574c979e911763d6387db45cc
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    commit 600ddd6825543962fb807884169e57b580dba208 upstream.
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Zefan Li <lizefan@huawei.com>

commit faf1368dedf9cc98ef35c9ec6d2677ff5e98b090
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    [ Upstream commit 600ddd6825543962fb807884169e57b580dba208 ]
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c75e4b05b591b6c134b7e66c1ea39757f452f1e8
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    [ Upstream commit 600ddd6825543962fb807884169e57b580dba208 ]
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 727ab4c06af65c1b2313c95dfcd8827318d5a438
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    [ Upstream commit 600ddd6825543962fb807884169e57b580dba208 ]
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8662a896ae1ff85dca6797a0e9977a4794b67847
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    commit 600ddd6825543962fb807884169e57b580dba208 upstream.
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 43e39c2f63240f67a67b4060882f67dac1a6f339
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    [ Upstream commit 600ddd6825543962fb807884169e57b580dba208 ]
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit 72d7e0fe4d22352f69c87bd3c058b05a68101706
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    commit 600ddd6825543962fb807884169e57b580dba208 upstream.
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Cc: Moritz Muehlenhoff <jmm@debian.org>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

commit 600ddd6825543962fb807884169e57b580dba208
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 24866e75aa5f9ae2b8917e9bec420f7b966d0836
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry picked from commit d3217b15a19a4779c39b212358a5c71d725822ee)
    [wt: fixes CVE-2014-4667]
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit fe33a3ee987dac85ac24b2d8147d2165051c80d9
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    [ Upstream commit d3217b15a19a4779c39b212358a5c71d725822ee ]
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit 07a0fcca063b5e6dadd1e4059580faf7b4c751c6
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    [ Upstream commit d3217b15a19a4779c39b212358a5c71d725822ee ]
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4c6c201fa9aa76b57b98c993826c4bd9ecb0f264
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    [ Upstream commit d3217b15a19a4779c39b212358a5c71d725822ee ]
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a6987bca8054bf0cf9e90a9b0d42486d7bc53d70
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    [ Upstream commit d3217b15a19a4779c39b212358a5c71d725822ee ]
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3309a9750b319afc809caa29b8091e9746ec8ce0
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    [ Upstream commit d3217b15a19a4779c39b212358a5c71d725822ee ]
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ddb638e68690ca61959775b262a5ef0719c5c066
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    [ Upstream commit d3217b15a19a4779c39b212358a5c71d725822ee ]
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit d3217b15a19a4779c39b212358a5c71d725822ee
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7658e7de68b967b01be536c998b0b90d0b6ec013
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Apr 9 16:10:20 2014 +0200

    net: sctp: test if association is dead in sctp_wake_up_waiters
    
    [ Upstream commit 1e1cdf8ac78793e0875465e98a648df64694a8d0 ]
    
    In function sctp_wake_up_waiters(), we need to involve a test
    if the association is declared dead. If so, we don't have any
    reference to a possible sibling association anymore and need
    to invoke sctp_write_space() instead, and normally walk the
    socket's associations and notify them of new wmem space. The
    reason for special casing is that otherwise, we could run
    into the following issue when a sctp_primitive_SEND() call
    from sctp_sendmsg() fails, and tries to flush an association's
    outq, i.e. in the following way:
    
    sctp_association_free()
    `-> list_del(&asoc->asocs)         <-- poisons list pointer
        asoc->base.dead = true
        sctp_outq_free(&asoc->outqueue)
        `-> __sctp_outq_teardown()
         `-> sctp_chunk_free()
          `-> consume_skb()
           `-> sctp_wfree()
            `-> sctp_wake_up_waiters() <-- dereferences poisoned pointers
                                           if asoc->ep->sndbuf_policy=0
    
    Therefore, only walk the list in an 'optimized' way if we find
    that the current association is still active. We could also use
    list_del_init() in addition when we call sctp_association_free(),
    but as Vlad suggests, we want to trap such bugs and thus leave
    it poisoned as is.
    
    Why is it safe to resolve the issue by testing for asoc->base.dead?
    Parallel calls to sctp_sendmsg() are protected under socket lock,
    that is lock_sock()/release_sock(). Only within that path under
    lock held, we're setting skb/chunk owner via sctp_set_owner_w().
    Eventually, chunks are freed directly by an association still
    under that lock. So when traversing association list on destruction
    time from sctp_wake_up_waiters() via sctp_wfree(), a different
    CPU can't be running sctp_wfree() while another one calls
    sctp_association_free() as both happens under the same lock.
    Therefore, this can also not race with setting/testing against
    asoc->base.dead as we are guaranteed for this to happen in order,
    under lock. Further, Vlad says: the times we check asoc->base.dead
    is when we've cached an association pointer for later processing.
    In between cache and processing, the association may have been
    freed and is simply still around due to reference counts. We check
    asoc->base.dead under a lock, so it should always be safe to check
    and not race against sctp_association_free(). Stress-testing seems
    fine now, too.
    
    Fixes: cd253f9f357d ("net: sctp: wake up all assocs if sndbuf policy is per socket")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 42c15611b670e03185f78bfdc8b6eaa3596b1049
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Apr 9 16:10:20 2014 +0200

    net: sctp: test if association is dead in sctp_wake_up_waiters
    
    [ Upstream commit 1e1cdf8ac78793e0875465e98a648df64694a8d0 ]
    
    In function sctp_wake_up_waiters(), we need to involve a test
    if the association is declared dead. If so, we don't have any
    reference to a possible sibling association anymore and need
    to invoke sctp_write_space() instead, and normally walk the
    socket's associations and notify them of new wmem space. The
    reason for special casing is that otherwise, we could run
    into the following issue when a sctp_primitive_SEND() call
    from sctp_sendmsg() fails, and tries to flush an association's
    outq, i.e. in the following way:
    
    sctp_association_free()
    `-> list_del(&asoc->asocs)         <-- poisons list pointer
        asoc->base.dead = true
        sctp_outq_free(&asoc->outqueue)
        `-> __sctp_outq_teardown()
         `-> sctp_chunk_free()
          `-> consume_skb()
           `-> sctp_wfree()
            `-> sctp_wake_up_waiters() <-- dereferences poisoned pointers
                                           if asoc->ep->sndbuf_policy=0
    
    Therefore, only walk the list in an 'optimized' way if we find
    that the current association is still active. We could also use
    list_del_init() in addition when we call sctp_association_free(),
    but as Vlad suggests, we want to trap such bugs and thus leave
    it poisoned as is.
    
    Why is it safe to resolve the issue by testing for asoc->base.dead?
    Parallel calls to sctp_sendmsg() are protected under socket lock,
    that is lock_sock()/release_sock(). Only within that path under
    lock held, we're setting skb/chunk owner via sctp_set_owner_w().
    Eventually, chunks are freed directly by an association still
    under that lock. So when traversing association list on destruction
    time from sctp_wake_up_waiters() via sctp_wfree(), a different
    CPU can't be running sctp_wfree() while another one calls
    sctp_association_free() as both happens under the same lock.
    Therefore, this can also not race with setting/testing against
    asoc->base.dead as we are guaranteed for this to happen in order,
    under lock. Further, Vlad says: the times we check asoc->base.dead
    is when we've cached an association pointer for later processing.
    In between cache and processing, the association may have been
    freed and is simply still around due to reference counts. We check
    asoc->base.dead under a lock, so it should always be safe to check
    and not race against sctp_association_free(). Stress-testing seems
    fine now, too.
    
    Fixes: cd253f9f357d ("net: sctp: wake up all assocs if sndbuf policy is per socket")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3947574d9ccb493843d518fea97f92f6acdb8c8a
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Apr 9 16:10:20 2014 +0200

    net: sctp: test if association is dead in sctp_wake_up_waiters
    
    [ Upstream commit 1e1cdf8ac78793e0875465e98a648df64694a8d0 ]
    
    In function sctp_wake_up_waiters(), we need to involve a test
    if the association is declared dead. If so, we don't have any
    reference to a possible sibling association anymore and need
    to invoke sctp_write_space() instead, and normally walk the
    socket's associations and notify them of new wmem space. The
    reason for special casing is that otherwise, we could run
    into the following issue when a sctp_primitive_SEND() call
    from sctp_sendmsg() fails, and tries to flush an association's
    outq, i.e. in the following way:
    
    sctp_association_free()
    `-> list_del(&asoc->asocs)         <-- poisons list pointer
        asoc->base.dead = true
        sctp_outq_free(&asoc->outqueue)
        `-> __sctp_outq_teardown()
         `-> sctp_chunk_free()
          `-> consume_skb()
           `-> sctp_wfree()
            `-> sctp_wake_up_waiters() <-- dereferences poisoned pointers
                                           if asoc->ep->sndbuf_policy=0
    
    Therefore, only walk the list in an 'optimized' way if we find
    that the current association is still active. We could also use
    list_del_init() in addition when we call sctp_association_free(),
    but as Vlad suggests, we want to trap such bugs and thus leave
    it poisoned as is.
    
    Why is it safe to resolve the issue by testing for asoc->base.dead?
    Parallel calls to sctp_sendmsg() are protected under socket lock,
    that is lock_sock()/release_sock(). Only within that path under
    lock held, we're setting skb/chunk owner via sctp_set_owner_w().
    Eventually, chunks are freed directly by an association still
    under that lock. So when traversing association list on destruction
    time from sctp_wake_up_waiters() via sctp_wfree(), a different
    CPU can't be running sctp_wfree() while another one calls
    sctp_association_free() as both happens under the same lock.
    Therefore, this can also not race with setting/testing against
    asoc->base.dead as we are guaranteed for this to happen in order,
    under lock. Further, Vlad says: the times we check asoc->base.dead
    is when we've cached an association pointer for later processing.
    In between cache and processing, the association may have been
    freed and is simply still around due to reference counts. We check
    asoc->base.dead under a lock, so it should always be safe to check
    and not race against sctp_association_free(). Stress-testing seems
    fine now, too.
    
    Fixes: cd253f9f357d ("net: sctp: wake up all assocs if sndbuf policy is per socket")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 568491238ce069e51b20768f66c1449d4fb43807
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Apr 9 16:10:20 2014 +0200

    net: sctp: test if association is dead in sctp_wake_up_waiters
    
    [ Upstream commit 1e1cdf8ac78793e0875465e98a648df64694a8d0 ]
    
    In function sctp_wake_up_waiters(), we need to involve a test
    if the association is declared dead. If so, we don't have any
    reference to a possible sibling association anymore and need
    to invoke sctp_write_space() instead, and normally walk the
    socket's associations and notify them of new wmem space. The
    reason for special casing is that otherwise, we could run
    into the following issue when a sctp_primitive_SEND() call
    from sctp_sendmsg() fails, and tries to flush an association's
    outq, i.e. in the following way:
    
    sctp_association_free()
    `-> list_del(&asoc->asocs)         <-- poisons list pointer
        asoc->base.dead = true
        sctp_outq_free(&asoc->outqueue)
        `-> __sctp_outq_teardown()
         `-> sctp_chunk_free()
          `-> consume_skb()
           `-> sctp_wfree()
            `-> sctp_wake_up_waiters() <-- dereferences poisoned pointers
                                           if asoc->ep->sndbuf_policy=0
    
    Therefore, only walk the list in an 'optimized' way if we find
    that the current association is still active. We could also use
    list_del_init() in addition when we call sctp_association_free(),
    but as Vlad suggests, we want to trap such bugs and thus leave
    it poisoned as is.
    
    Why is it safe to resolve the issue by testing for asoc->base.dead?
    Parallel calls to sctp_sendmsg() are protected under socket lock,
    that is lock_sock()/release_sock(). Only within that path under
    lock held, we're setting skb/chunk owner via sctp_set_owner_w().
    Eventually, chunks are freed directly by an association still
    under that lock. So when traversing association list on destruction
    time from sctp_wake_up_waiters() via sctp_wfree(), a different
    CPU can't be running sctp_wfree() while another one calls
    sctp_association_free() as both happens under the same lock.
    Therefore, this can also not race with setting/testing against
    asoc->base.dead as we are guaranteed for this to happen in order,
    under lock. Further, Vlad says: the times we check asoc->base.dead
    is when we've cached an association pointer for later processing.
    In between cache and processing, the association may have been
    freed and is simply still around due to reference counts. We check
    asoc->base.dead under a lock, so it should always be safe to check
    and not race against sctp_association_free(). Stress-testing seems
    fine now, too.
    
    Fixes: cd253f9f357d ("net: sctp: wake up all assocs if sndbuf policy is per socket")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>

commit e409e24ad51215dc0e816aa42e2914fc7911e93d
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jun 12 14:26:44 2013 -0400

    sctp: fully initialize sctp_outq in sctp_outq_init
    
    [ Upstream commit c5c7774d7eb4397891edca9ebdf750ba90977a69 ]
    
    In commit 2f94aabd9f6c925d77aecb3ff020f1cc12ed8f86
    (refactor sctp_outq_teardown to insure proper re-initalization)
    we modified sctp_outq_teardown to use sctp_outq_init to fully re-initalize the
    outq structure.  Steve West recently asked me why I removed the q->error = 0
    initalization from sctp_outq_teardown.  I did so because I was operating under
    the impression that sctp_outq_init would properly initalize that value for us,
    but it doesn't.  sctp_outq_init operates under the assumption that the outq
    struct is all 0's (as it is when called from sctp_association_init), but using
    it in __sctp_outq_teardown violates that assumption. We should do a memset in
    sctp_outq_init to ensure that the entire structure is in a known state there
    instead.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: "West, Steve (NSN - US/Fort Worth)" <steve.west@nsn.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    CC: davem@davemloft.net
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 1e1cdf8ac78793e0875465e98a648df64694a8d0
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Apr 9 16:10:20 2014 +0200

    net: sctp: test if association is dead in sctp_wake_up_waiters
    
    In function sctp_wake_up_waiters(), we need to involve a test
    if the association is declared dead. If so, we don't have any
    reference to a possible sibling association anymore and need
    to invoke sctp_write_space() instead, and normally walk the
    socket's associations and notify them of new wmem space. The
    reason for special casing is that otherwise, we could run
    into the following issue when a sctp_primitive_SEND() call
    from sctp_sendmsg() fails, and tries to flush an association's
    outq, i.e. in the following way:
    
    sctp_association_free()
    `-> list_del(&asoc->asocs)         <-- poisons list pointer
        asoc->base.dead = true
        sctp_outq_free(&asoc->outqueue)
        `-> __sctp_outq_teardown()
         `-> sctp_chunk_free()
          `-> consume_skb()
           `-> sctp_wfree()
            `-> sctp_wake_up_waiters() <-- dereferences poisoned pointers
                                           if asoc->ep->sndbuf_policy=0
    
    Therefore, only walk the list in an 'optimized' way if we find
    that the current association is still active. We could also use
    list_del_init() in addition when we call sctp_association_free(),
    but as Vlad suggests, we want to trap such bugs and thus leave
    it poisoned as is.
    
    Why is it safe to resolve the issue by testing for asoc->base.dead?
    Parallel calls to sctp_sendmsg() are protected under socket lock,
    that is lock_sock()/release_sock(). Only within that path under
    lock held, we're setting skb/chunk owner via sctp_set_owner_w().
    Eventually, chunks are freed directly by an association still
    under that lock. So when traversing association list on destruction
    time from sctp_wake_up_waiters() via sctp_wfree(), a different
    CPU can't be running sctp_wfree() while another one calls
    sctp_association_free() as both happens under the same lock.
    Therefore, this can also not race with setting/testing against
    asoc->base.dead as we are guaranteed for this to happen in order,
    under lock. Further, Vlad says: the times we check asoc->base.dead
    is when we've cached an association pointer for later processing.
    In between cache and processing, the association may have been
    freed and is simply still around due to reference counts. We check
    asoc->base.dead under a lock, so it should always be safe to check
    and not race against sctp_association_free(). Stress-testing seems
    fine now, too.
    
    Fixes: cd253f9f357d ("net: sctp: wake up all assocs if sndbuf policy is per socket")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ef2820a735f74ea60335f8ba3801b844f0cb184d
Author: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nsn.com>
Date:   Fri Feb 14 14:51:18 2014 +0100

    net: sctp: Fix a_rwnd/rwnd management to reflect real state of the receiver's buffer
    
    Implementation of (a)rwnd calculation might lead to severe performance issues
    and associations completely stalling. These problems are described and solution
    is proposed which improves lksctp's robustness in congestion state.
    
    1) Sudden drop of a_rwnd and incomplete window recovery afterwards
    
    Data accounted in sctp_assoc_rwnd_decrease takes only payload size (sctp data),
    but size of sk_buff, which is blamed against receiver buffer, is not accounted
    in rwnd. Theoretically, this should not be the problem as actual size of buffer
    is double the amount requested on the socket (SO_RECVBUF). Problem here is
    that this will have bad scaling for data which is less then sizeof sk_buff.
    E.g. in 4G (LTE) networks, link interfacing radio side will have a large portion
    of traffic of this size (less then 100B).
    
    An example of sudden drop and incomplete window recovery is given below. Node B
    exhibits problematic behavior. Node A initiates association and B is configured
    to advertise rwnd of 10000. A sends messages of size 43B (size of typical sctp
    message in 4G (LTE) network). On B data is left in buffer by not reading socket
    in userspace.
    
    Lets examine when we will hit pressure state and declare rwnd to be 0 for
    scenario with above stated parameters (rwnd == 10000, chunk size == 43, each
    chunk is sent in separate sctp packet)
    
    Logic is implemented in sctp_assoc_rwnd_decrease:
    
    socket_buffer (see below) is maximum size which can be held in socket buffer
    (sk_rcvbuf). current_alloced is amount of data currently allocated (rx_count)
    
    A simple expression is given for which it will be examined after how many
    packets for above stated parameters we enter pressure state:
    
    We start by condition which has to be met in order to enter pressure state:
    
            socket_buffer < currently_alloced;
    
    currently_alloced is represented as size of sctp packets received so far and not
    yet delivered to userspace. x is the number of chunks/packets (since there is no
    bundling, and each chunk is delivered in separate packet, we can observe each
    chunk also as sctp packet, and what is important here, having its own sk_buff):
    
            socket_buffer < x*each_sctp_packet;
    
    each_sctp_packet is sctp chunk size + sizeof(struct sk_buff). socket_buffer is
    twice the amount of initially requested size of socket buffer, which is in case
    of sctp, twice the a_rwnd requested:
    
            2*rwnd < x*(payload+sizeof(struc sk_buff));
    
    sizeof(struct sk_buff) is 190 (3.13.0-rc4+). Above is stated that rwnd is 10000
    and each payload size is 43
    
            20000 < x(43+190);
    
            x > 20000/233;
    
            x ~> 84;
    
    After ~84 messages, pressure state is entered and 0 rwnd is advertised while
    received 84*43B ~= 3612B sctp data. This is why external observer notices sudden
    drop from 6474 to 0, as it will be now shown in example:
    
    IP A.34340 > B.12345: sctp (1) [INIT] [init tag: 1875509148] [rwnd: 81920] [OS: 10] [MIS: 65535] [init TSN: 1096057017]
    IP B.12345 > A.34340: sctp (1) [INIT ACK] [init tag: 3198966556] [rwnd: 10000] [OS: 10] [MIS: 10] [init TSN: 902132839]
    IP A.34340 > B.12345: sctp (1) [COOKIE ECHO]
    IP B.12345 > A.34340: sctp (1) [COOKIE ACK]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057017] [SID: 0] [SSEQ 0] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057017] [a_rwnd 9957] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057018] [SID: 0] [SSEQ 1] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057018] [a_rwnd 9957] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057019] [SID: 0] [SSEQ 2] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057019] [a_rwnd 9914] [#gap acks 0] [#dup tsns 0]
    <...>
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057098] [SID: 0] [SSEQ 81] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057098] [a_rwnd 6517] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057099] [SID: 0] [SSEQ 82] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057099] [a_rwnd 6474] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057100] [SID: 0] [SSEQ 83] [PPID 0x18]
    
    --> Sudden drop
    
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057100] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    At this point, rwnd_press stores current rwnd value so it can be later restored
    in sctp_assoc_rwnd_increase. This however doesn't happen as condition to start
    slowly increasing rwnd until rwnd_press is returned to rwnd is never met. This
    condition is not met since rwnd, after it hit 0, must first reach rwnd_press by
    adding amount which is read from userspace. Let us observe values in above
    example. Initial a_rwnd is 10000, pressure was hit when rwnd was ~6500 and the
    amount of actual sctp data currently waiting to be delivered to userspace
    is ~3500. When userspace starts to read, sctp_assoc_rwnd_increase will be blamed
    only for sctp data, which is ~3500. Condition is never met, and when userspace
    reads all data, rwnd stays on 3569.
    
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057100] [a_rwnd 1505] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057100] [a_rwnd 3010] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057101] [SID: 0] [SSEQ 84] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057101] [a_rwnd 3569] [#gap acks 0] [#dup tsns 0]
    
    --> At this point userspace read everything, rwnd recovered only to 3569
    
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057102] [SID: 0] [SSEQ 85] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057102] [a_rwnd 3569] [#gap acks 0] [#dup tsns 0]
    
    Reproduction is straight forward, it is enough for sender to send packets of
    size less then sizeof(struct sk_buff) and receiver keeping them in its buffers.
    
    2) Minute size window for associations sharing the same socket buffer
    
    In case multiple associations share the same socket, and same socket buffer
    (sctp.rcvbuf_policy == 0), different scenarios exist in which congestion on one
    of the associations can permanently drop rwnd of other association(s).
    
    Situation will be typically observed as one association suddenly having rwnd
    dropped to size of last packet received and never recovering beyond that point.
    Different scenarios will lead to it, but all have in common that one of the
    associations (let it be association from 1)) nearly depleted socket buffer, and
    the other association blames socket buffer just for the amount enough to start
    the pressure. This association will enter pressure state, set rwnd_press and
    announce 0 rwnd.
    When data is read by userspace, similar situation as in 1) will occur, rwnd will
    increase just for the size read by userspace but rwnd_press will be high enough
    so that association doesn't have enough credit to reach rwnd_press and restore
    to previous state. This case is special case of 1), being worse as there is, in
    the worst case, only one packet in buffer for which size rwnd will be increased.
    Consequence is association which has very low maximum rwnd ('minute size', in
    our case down to 43B - size of packet which caused pressure) and as such
    unusable.
    
    Scenario happened in the field and labs frequently after congestion state (link
    breaks, different probabilities of packet drop, packet reordering) and with
    scenario 1) preceding. Here is given a deterministic scenario for reproduction:
    
    >From node A establish two associations on the same socket, with rcvbuf_policy
    being set to share one common buffer (sctp.rcvbuf_policy == 0). On association 1
    repeat scenario from 1), that is, bring it down to 0 and restore up. Observe
    scenario 1). Use small payload size (here we use 43). Once rwnd is 'recovered',
    bring it down close to 0, as in just one more packet would close it. This has as
    a consequence that association number 2 is able to receive (at least) one more
    packet which will bring it in pressure state. E.g. if association 2 had rwnd of
    10000, packet received was 43, and we enter at this point into pressure,
    rwnd_press will have 9957. Once payload is delivered to userspace, rwnd will
    increase for 43, but conditions to restore rwnd to original state, just as in
    1), will never be satisfied.
    
    --> Association 1, between A.y and B.12345
    
    IP A.55915 > B.12345: sctp (1) [INIT] [init tag: 836880897] [rwnd: 10000] [OS: 10] [MIS: 65535] [init TSN: 4032536569]
    IP B.12345 > A.55915: sctp (1) [INIT ACK] [init tag: 2873310749] [rwnd: 81920] [OS: 10] [MIS: 10] [init TSN: 3799315613]
    IP A.55915 > B.12345: sctp (1) [COOKIE ECHO]
    IP B.12345 > A.55915: sctp (1) [COOKIE ACK]
    
    --> Association 2, between A.z and B.12346
    
    IP A.55915 > B.12346: sctp (1) [INIT] [init tag: 534798321] [rwnd: 10000] [OS: 10] [MIS: 65535] [init TSN: 2099285173]
    IP B.12346 > A.55915: sctp (1) [INIT ACK] [init tag: 516668823] [rwnd: 81920] [OS: 10] [MIS: 10] [init TSN: 3676403240]
    IP A.55915 > B.12346: sctp (1) [COOKIE ECHO]
    IP B.12346 > A.55915: sctp (1) [COOKIE ACK]
    
    --> Deplete socket buffer by sending messages of size 43B over association 1
    
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315613] [SID: 0] [SSEQ 0] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315613] [a_rwnd 9957] [#gap acks 0] [#dup tsns 0]
    
    <...>
    
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315696] [a_rwnd 6388] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315697] [SID: 0] [SSEQ 84] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315697] [a_rwnd 6345] [#gap acks 0] [#dup tsns 0]
    
    --> Sudden drop on 1
    
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315698] [SID: 0] [SSEQ 85] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315698] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    --> Here userspace read, rwnd 'recovered' to 3698, now deplete again using
        association 1 so there is place in buffer for only one more packet
    
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315799] [SID: 0] [SSEQ 186] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315799] [a_rwnd 86] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315800] [SID: 0] [SSEQ 187] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315800] [a_rwnd 43] [#gap acks 0] [#dup tsns 0]
    
    --> Socket buffer is almost depleted, but there is space for one more packet,
        send them over association 2, size 43B
    
    IP B.12346 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3676403240] [SID: 0] [SSEQ 0] [PPID 0x18]
    IP A.55915 > B.12346: sctp (1) [SACK] [cum ack 3676403240] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    --> Immediate drop
    
    IP A.60995 > B.12346: sctp (1) [SACK] [cum ack 387491510] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    --> Read everything from the socket, both association recover up to maximum rwnd
        they are capable of reaching, note that association 1 recovered up to 3698,
        and association 2 recovered only to 43
    
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315800] [a_rwnd 1548] [#gap acks 0] [#dup tsns 0]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315800] [a_rwnd 3053] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315801] [SID: 0] [SSEQ 188] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315801] [a_rwnd 3698] [#gap acks 0] [#dup tsns 0]
    IP B.12346 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3676403241] [SID: 0] [SSEQ 1] [PPID 0x18]
    IP A.55915 > B.12346: sctp (1) [SACK] [cum ack 3676403241] [a_rwnd 43] [#gap acks 0] [#dup tsns 0]
    
    A careful reader might wonder why it is necessary to reproduce 1) prior
    reproduction of 2). It is simply easier to observe when to send packet over
    association 2 which will push association into the pressure state.
    
    Proposed solution:
    
    Both problems share the same root cause, and that is improper scaling of socket
    buffer with rwnd. Solution in which sizeof(sk_buff) is taken into concern while
    calculating rwnd is not possible due to fact that there is no linear
    relationship between amount of data blamed in increase/decrease with IP packet
    in which payload arrived. Even in case such solution would be followed,
    complexity of the code would increase. Due to nature of current rwnd handling,
    slow increase (in sctp_assoc_rwnd_increase) of rwnd after pressure state is
    entered is rationale, but it gives false representation to the sender of current
    buffer space. Furthermore, it implements additional congestion control mechanism
    which is defined on implementation, and not on standard basis.
    
    Proposed solution simplifies whole algorithm having on mind definition from rfc:
    
    o  Receiver Window (rwnd): This gives the sender an indication of the space
       available in the receiver's inbound buffer.
    
    Core of the proposed solution is given with these lines:
    
    sctp_assoc_rwnd_update:
            if ((asoc->base.sk->sk_rcvbuf - rx_count) > 0)
                    asoc->rwnd = (asoc->base.sk->sk_rcvbuf - rx_count) >> 1;
            else
                    asoc->rwnd = 0;
    
    We advertise to sender (half of) actual space we have. Half is in the braces
    depending whether you would like to observe size of socket buffer as SO_RECVBUF
    or twice the amount, i.e. size is the one visible from userspace, that is,
    from kernelspace.
    In this way sender is given with good approximation of our buffer space,
    regardless of the buffer policy - we always advertise what we have. Proposed
    solution fixes described problems and removes necessity for rwnd restoration
    algorithm. Finally, as proposed solution is simplification, some lines of code,
    along with some bytes in struct sctp_association are saved.
    
    Version 2 of the patch addressed comments from Vlad. Name of the function is set
    to be more descriptive, and two parts of code are changed, in one removing the
    superfluous call to sctp_assoc_rwnd_update since call would not result in update
    of rwnd, and the other being reordering of the code in a way that call to
    sctp_assoc_rwnd_update updates rwnd. Version 3 corrected change introduced in v2
    in a way that existing function is not reordered/copied in line, but it is
    correctly called. Thanks Vlad for suggesting.
    
    Signed-off-by: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nsn.com>
    Reviewed-by: Alexander Sverdlin <alexander.sverdlin@nsn.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 681c76440d4d1a0f1956f0f655931c12cfabd5bd
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jun 12 14:26:44 2013 -0400

    sctp: fully initialize sctp_outq in sctp_outq_init
    
    [ Upstream commit c5c7774d7eb4397891edca9ebdf750ba90977a69 ]
    
    In commit 2f94aabd9f6c925d77aecb3ff020f1cc12ed8f86
    (refactor sctp_outq_teardown to insure proper re-initalization)
    we modified sctp_outq_teardown to use sctp_outq_init to fully re-initalize the
    outq structure.  Steve West recently asked me why I removed the q->error = 0
    initalization from sctp_outq_teardown.  I did so because I was operating under
    the impression that sctp_outq_init would properly initalize that value for us,
    but it doesn't.  sctp_outq_init operates under the assumption that the outq
    struct is all 0's (as it is when called from sctp_association_init), but using
    it in __sctp_outq_teardown violates that assumption. We should do a memset in
    sctp_outq_init to ensure that the entire structure is in a known state there
    instead.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: "West, Steve (NSN - US/Fort Worth)" <steve.west@nsn.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    CC: davem@davemloft.net
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

commit d9a6f7174337a6d02b77e37fba6ab80bcf1ea528
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jun 12 14:26:44 2013 -0400

    sctp: fully initialize sctp_outq in sctp_outq_init
    
    [ Upstream commit c5c7774d7eb4397891edca9ebdf750ba90977a69 ]
    
    In commit 2f94aabd9f6c925d77aecb3ff020f1cc12ed8f86
    (refactor sctp_outq_teardown to insure proper re-initalization)
    we modified sctp_outq_teardown to use sctp_outq_init to fully re-initalize the
    outq structure.  Steve West recently asked me why I removed the q->error = 0
    initalization from sctp_outq_teardown.  I did so because I was operating under
    the impression that sctp_outq_init would properly initalize that value for us,
    but it doesn't.  sctp_outq_init operates under the assumption that the outq
    struct is all 0's (as it is when called from sctp_association_init), but using
    it in __sctp_outq_teardown violates that assumption. We should do a memset in
    sctp_outq_init to ensure that the entire structure is in a known state there
    instead.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: "West, Steve (NSN - US/Fort Worth)" <steve.west@nsn.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    CC: davem@davemloft.net
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a3c7417da6d8cdb421f6614d7ade485ead85da03
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jun 12 14:26:44 2013 -0400

    sctp: fully initialize sctp_outq in sctp_outq_init
    
    [ Upstream commit c5c7774d7eb4397891edca9ebdf750ba90977a69 ]
    
    In commit 2f94aabd9f6c925d77aecb3ff020f1cc12ed8f86
    (refactor sctp_outq_teardown to insure proper re-initalization)
    we modified sctp_outq_teardown to use sctp_outq_init to fully re-initalize the
    outq structure.  Steve West recently asked me why I removed the q->error = 0
    initalization from sctp_outq_teardown.  I did so because I was operating under
    the impression that sctp_outq_init would properly initalize that value for us,
    but it doesn't.  sctp_outq_init operates under the assumption that the outq
    struct is all 0's (as it is when called from sctp_association_init), but using
    it in __sctp_outq_teardown violates that assumption. We should do a memset in
    sctp_outq_init to ensure that the entire structure is in a known state there
    instead.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: "West, Steve (NSN - US/Fort Worth)" <steve.west@nsn.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    CC: davem@davemloft.net
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit cbeb69e0d16302877d2a44ab2311dcc733269db9
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jun 12 14:26:44 2013 -0400

    sctp: fully initialize sctp_outq in sctp_outq_init
    
    [ Upstream commit c5c7774d7eb4397891edca9ebdf750ba90977a69 ]
    
    In commit 2f94aabd9f6c925d77aecb3ff020f1cc12ed8f86
    (refactor sctp_outq_teardown to insure proper re-initalization)
    we modified sctp_outq_teardown to use sctp_outq_init to fully re-initalize the
    outq structure.  Steve West recently asked me why I removed the q->error = 0
    initalization from sctp_outq_teardown.  I did so because I was operating under
    the impression that sctp_outq_init would properly initalize that value for us,
    but it doesn't.  sctp_outq_init operates under the assumption that the outq
    struct is all 0's (as it is when called from sctp_association_init), but using
    it in __sctp_outq_teardown violates that assumption. We should do a memset in
    sctp_outq_init to ensure that the entire structure is in a known state there
    instead.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: "West, Steve (NSN - US/Fort Worth)" <steve.west@nsn.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    CC: davem@davemloft.net
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2e0c9e7911465b29daf85f7de97949004bf7b31c
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Jun 14 18:24:07 2013 +0200

    net: sctp: sctp_association_init: put refs in reverse order
    
    In case we need to bail out for whatever reason during assoc
    init, we call sctp_endpoint_put() and then sock_put(), however,
    we've hold both refs in reverse, non-symmetric order, so first
    sctp_endpoint_hold() and then sock_hold().
    
    Reverse this, so that in an error case we have sock_put() and then
    sctp_endpoint_put(). Actually shouldn't matter too much, since both
    cleanup paths do the right thing, but that way, it is more consistent
    with the rest of the code.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c5c7774d7eb4397891edca9ebdf750ba90977a69
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jun 12 14:26:44 2013 -0400

    sctp: fully initialize sctp_outq in sctp_outq_init
    
    In commit 2f94aabd9f6c925d77aecb3ff020f1cc12ed8f86
    (refactor sctp_outq_teardown to insure proper re-initalization)
    we modified sctp_outq_teardown to use sctp_outq_init to fully re-initalize the
    outq structure.  Steve West recently asked me why I removed the q->error = 0
    initalization from sctp_outq_teardown.  I did so because I was operating under
    the impression that sctp_outq_init would properly initalize that value for us,
    but it doesn't.  sctp_outq_init operates under the assumption that the outq
    struct is all 0's (as it is when called from sctp_association_init), but using
    it in __sctp_outq_teardown violates that assumption. We should do a memset in
    sctp_outq_init to ensure that the entire structure is in a known state there
    instead.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: "West, Steve (NSN - US/Fort Worth)" <steve.west@nsn.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    CC: davem@davemloft.net
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c1db7a26ac3f7223a38eaeb46a77d0cf9e6a0d8f
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:17 2013 +0000

    net: sctp: sctp_ulpq: remove 'malloced' struct member
    
    The structure sctp_ulpq is embedded into sctp_association and never
    separately allocated, also ulpq->malloced is always 0, so that
    kfree() is never called. Therefore, remove this code.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 165a4c31278c980862b2c2ddec408cf30341f3ec
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:12 2013 +0000

    net: sctp: sctp_outq: remove 'malloced' from its struct
    
    sctp_outq is embedded into sctp_association, and thus never
    kmalloced in any way. Also, malloced is always 0, thus kfree()
    is never called. Therefore, remove that dead piece of code.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ff2266cddd69f5e0c9d5121ed9218d2f694406cc
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Apr 15 03:27:17 2013 +0000

    net: sctp: remove sctp_ep_common struct member 'malloced'
    
    There is actually no need to keep this member in the structure, because
    after init it's always 1 anyway, thus always kfree called. This seems to
    be an ancient leftover from the very initial implementation from 2.5
    times. Only in case the initialization of an association fails, we leave
    base.malloced as 0, but we nevertheless kfree it in the error path in
    sctp_association_new().
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8c98653f05534acd1cb07ea4929702a3659177d1
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Feb 1 04:37:43 2013 +0000

    sctp: sctp_close: fix release of bindings for deferred call_rcu's
    
    It seems due to RCU usage, i.e. within SCTP's address binding list,
    a, say, ``behavioral change'' was introduced which does actually
    not conform to the RFC anymore. In particular consider the following
    (fictional) scenario to demonstrate this:
    
      do:
        Two SOCK_SEQPACKET-style sockets are opened (S1, S2)
        S1 is bound to 127.0.0.1, port 1024 [server]
        S2 is bound to 127.0.0.1, port 1025 [client]
        listen(2) is invoked on S1
        From S2 we call one sendmsg(2) with msg.msg_name and
           msg.msg_namelen parameters set to the server's
           address
        S1, S2 are closed
        goto do
    
    The first pass of this loop passes successful, while the second round
    fails during binding of S1 (address still in use). What is happening?
    In the first round, the initial handshake is being done, and, at the
    time close(2) is called on S1, a non-graceful shutdown is performed via
    ABORT since in S1's receive queue an unprocessed packet is present,
    thus stating an error condition. This can be considered as a correct
    behavior.
    
    During close also all bound addresses are freed, thus nothing *must*
    be active anymore. In reference to RFC2960:
    
      After checking the Verification Tag, the receiving endpoint shall
      remove the association from its record, and shall report the
      termination to its upper layer. (9.1 Abort of an Association)
    
    Also, no half-open states are supported, thus after an ungraceful
    shutdown, we leave nothing behind. However, this seems not to be
    happening though. In a real-world scenario, this is exactly where
    it breaks the lksctp-tools functional test suite, *for instance*:
    
      ./test_sockopt
      test_sockopt.c  1 PASS : getsockopt(SCTP_STATUS) on a socket with no assoc
      test_sockopt.c  2 PASS : getsockopt(SCTP_STATUS)
      test_sockopt.c  3 PASS : getsockopt(SCTP_STATUS) with invalid associd
      test_sockopt.c  4 PASS : getsockopt(SCTP_STATUS) with NULL associd
      test_sockopt.c  5 BROK : bind: Address already in use
    
    The underlying problem is that sctp_endpoint_destroy() hasn't been
    triggered yet while the next bind attempt is being done. It will be
    triggered eventually (but too late) by sctp_transport_destroy_rcu()
    after one RCU grace period:
    
      sctp_transport_destroy()
        sctp_transport_destroy_rcu() ----.
          sctp_association_put() [*]  <--+--> sctp_packet_free()
            sctp_association_destroy()          [...]
              sctp_endpoint_put()                 skb->destructor
                sctp_endpoint_destroy()             sctp_wfree()
                  sctp_bind_addr_free()               sctp_association_put() [*]
    
    Thus, we move out the condition with sctp_association_put() as well as
    the sctp_packet_free() invocation and the issue can be solved. We also
    better free the SCTP chunks first before putting the ref of the association.
    
    With this patch, the example above (which simulates a similar scenario
    as in the implementation of this test case) and therefore also the test
    suite run successfully through. Tested by myself.
    
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 45122ca26ced7fae41049326a3797a73f961db2e
Author: Thomas Graf <tgraf@suug.ch>
Date:   Thu Dec 6 09:25:05 2012 +0000

    sctp: Add RCU protection to assoc->transport_addr_list
    
    peer.transport_addr_list is currently only protected by sk_sock
    which is inpractical to acquire for procfs dumping purposes.
    
    This patch adds RCU protection allowing for the procfs readers to
    enter RCU read-side critical sections.
    
    Modification of the list continues to be serialized via sk_lock.
    
    V2: Use list_del_rcu() in sctp_association_free() to be safe
        Skip transports marked dead when dumping for procfs
    
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0343c5543b1d3ffa08e6716d82afb62648b80eba
Author: Benjamin Poirier <bpoirier@suse.de>
Date:   Thu Mar 8 05:55:58 2012 +0000

    sctp: Export sctp_do_peeloff
    
    lookup sctp_association within sctp_do_peeloff() to enable its use outside of
    the sctp code with minimal knowledge of the former.
    
    Signed-off-by: Benjamin Poirier <bpoirier@suse.de>
    Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ad801fa0f9c4c08c75c506cc5d3cd0ab18a6ded3
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu May 6 00:56:07 2010 -0700

    sctp: Fix a race between ICMP protocol unreachable and connect()
    
    commit 50b5d6ad63821cea324a5a7a19854d4de1a0a819 upstream.
    
    ICMP protocol unreachable handling completely disregarded
    the fact that the user may have locked the socket.  It proceeded
    to destroy the association, even though the user may have
    held the lock and had a ref on the association.  This resulted
    in the following:
    
    Attempt to release alive inet socket f6afcc00
    
    =========================
    [ BUG: held lock freed! ]
    -------------------------
    somenu/2672 is freeing memory f6afcc00-f6afcfff, with a lock still held
    there!
     (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    1 lock held by somenu/2672:
     #0:  (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    
    stack backtrace:
    Pid: 2672, comm: somenu Not tainted 2.6.32-telco #55
    Call Trace:
     [<c1232266>] ? printk+0xf/0x11
     [<c1038553>] debug_check_no_locks_freed+0xce/0xff
     [<c10620b4>] kmem_cache_free+0x21/0x66
     [<c1185f25>] __sk_free+0x9d/0xab
     [<c1185f9c>] sk_free+0x1c/0x1e
     [<c1216e38>] sctp_association_put+0x32/0x89
     [<c1220865>] __sctp_connect+0x36d/0x3f4
     [<c122098a>] ? sctp_connect+0x13/0x4c
     [<c102d073>] ? autoremove_wake_function+0x0/0x33
     [<c12209a8>] sctp_connect+0x31/0x4c
     [<c11d1e80>] inet_dgram_connect+0x4b/0x55
     [<c11834fa>] sys_connect+0x54/0x71
     [<c103a3a2>] ? lock_release_non_nested+0x88/0x239
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c11847ab>] sys_socketcall+0x6d/0x178
     [<c10da994>] ? trace_hardirqs_on_thunk+0xc/0x10
     [<c1002959>] syscall_call+0x7/0xb
    
    This was because the sctp_wait_for_connect() would aqcure the socket
    lock and then proceed to release the last reference count on the
    association, thus cause the fully destruction path to finish freeing
    the socket.
    
    The simplest solution is to start a very short timer in case the socket
    is owned by user.  When the timer expires, we can do some verification
    and be able to do the release properly.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 4746f7abc3f13246147e7f6c0d219876417001fa
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu May 6 00:56:07 2010 -0700

    sctp: Fix a race between ICMP protocol unreachable and connect()
    
    commit 50b5d6ad63821cea324a5a7a19854d4de1a0a819 upstream.
    
    ICMP protocol unreachable handling completely disregarded
    the fact that the user may have locked the socket.  It proceeded
    to destroy the association, even though the user may have
    held the lock and had a ref on the association.  This resulted
    in the following:
    
    Attempt to release alive inet socket f6afcc00
    
    =========================
    [ BUG: held lock freed! ]
    -------------------------
    somenu/2672 is freeing memory f6afcc00-f6afcfff, with a lock still held
    there!
     (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    1 lock held by somenu/2672:
     #0:  (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    
    stack backtrace:
    Pid: 2672, comm: somenu Not tainted 2.6.32-telco #55
    Call Trace:
     [<c1232266>] ? printk+0xf/0x11
     [<c1038553>] debug_check_no_locks_freed+0xce/0xff
     [<c10620b4>] kmem_cache_free+0x21/0x66
     [<c1185f25>] __sk_free+0x9d/0xab
     [<c1185f9c>] sk_free+0x1c/0x1e
     [<c1216e38>] sctp_association_put+0x32/0x89
     [<c1220865>] __sctp_connect+0x36d/0x3f4
     [<c122098a>] ? sctp_connect+0x13/0x4c
     [<c102d073>] ? autoremove_wake_function+0x0/0x33
     [<c12209a8>] sctp_connect+0x31/0x4c
     [<c11d1e80>] inet_dgram_connect+0x4b/0x55
     [<c11834fa>] sys_connect+0x54/0x71
     [<c103a3a2>] ? lock_release_non_nested+0x88/0x239
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c11847ab>] sys_socketcall+0x6d/0x178
     [<c10da994>] ? trace_hardirqs_on_thunk+0xc/0x10
     [<c1002959>] syscall_call+0x7/0xb
    
    This was because the sctp_wait_for_connect() would aqcure the socket
    lock and then proceed to release the last reference count on the
    association, thus cause the fully destruction path to finish freeing
    the socket.
    
    The simplest solution is to start a very short timer in case the socket
    is owned by user.  When the timer expires, we can do some verification
    and be able to do the release properly.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

commit 6552df6df2fcfc281c64dea191fef144d5a188c5
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu May 6 00:56:07 2010 -0700

    sctp: Fix a race between ICMP protocol unreachable and connect()
    
    commit 50b5d6ad63821cea324a5a7a19854d4de1a0a819 upstream.
    
    ICMP protocol unreachable handling completely disregarded
    the fact that the user may have locked the socket.  It proceeded
    to destroy the association, even though the user may have
    held the lock and had a ref on the association.  This resulted
    in the following:
    
    Attempt to release alive inet socket f6afcc00
    
    =========================
    [ BUG: held lock freed! ]
    -------------------------
    somenu/2672 is freeing memory f6afcc00-f6afcfff, with a lock still held
    there!
     (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    1 lock held by somenu/2672:
     #0:  (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    
    stack backtrace:
    Pid: 2672, comm: somenu Not tainted 2.6.32-telco #55
    Call Trace:
     [<c1232266>] ? printk+0xf/0x11
     [<c1038553>] debug_check_no_locks_freed+0xce/0xff
     [<c10620b4>] kmem_cache_free+0x21/0x66
     [<c1185f25>] __sk_free+0x9d/0xab
     [<c1185f9c>] sk_free+0x1c/0x1e
     [<c1216e38>] sctp_association_put+0x32/0x89
     [<c1220865>] __sctp_connect+0x36d/0x3f4
     [<c122098a>] ? sctp_connect+0x13/0x4c
     [<c102d073>] ? autoremove_wake_function+0x0/0x33
     [<c12209a8>] sctp_connect+0x31/0x4c
     [<c11d1e80>] inet_dgram_connect+0x4b/0x55
     [<c11834fa>] sys_connect+0x54/0x71
     [<c103a3a2>] ? lock_release_non_nested+0x88/0x239
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c11847ab>] sys_socketcall+0x6d/0x178
     [<c10da994>] ? trace_hardirqs_on_thunk+0xc/0x10
     [<c1002959>] syscall_call+0x7/0xb
    
    This was because the sctp_wait_for_connect() would aqcure the socket
    lock and then proceed to release the last reference count on the
    association, thus cause the fully destruction path to finish freeing
    the socket.
    
    The simplest solution is to start a very short timer in case the socket
    is owned by user.  When the timer expires, we can do some verification
    and be able to do the release properly.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 50b5d6ad63821cea324a5a7a19854d4de1a0a819
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu May 6 00:56:07 2010 -0700

    sctp: Fix a race between ICMP protocol unreachable and connect()
    
    ICMP protocol unreachable handling completely disregarded
    the fact that the user may have locked the socket.  It proceeded
    to destroy the association, even though the user may have
    held the lock and had a ref on the association.  This resulted
    in the following:
    
    Attempt to release alive inet socket f6afcc00
    
    =========================
    [ BUG: held lock freed! ]
    -------------------------
    somenu/2672 is freeing memory f6afcc00-f6afcfff, with a lock still held
    there!
     (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    1 lock held by somenu/2672:
     #0:  (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    
    stack backtrace:
    Pid: 2672, comm: somenu Not tainted 2.6.32-telco #55
    Call Trace:
     [<c1232266>] ? printk+0xf/0x11
     [<c1038553>] debug_check_no_locks_freed+0xce/0xff
     [<c10620b4>] kmem_cache_free+0x21/0x66
     [<c1185f25>] __sk_free+0x9d/0xab
     [<c1185f9c>] sk_free+0x1c/0x1e
     [<c1216e38>] sctp_association_put+0x32/0x89
     [<c1220865>] __sctp_connect+0x36d/0x3f4
     [<c122098a>] ? sctp_connect+0x13/0x4c
     [<c102d073>] ? autoremove_wake_function+0x0/0x33
     [<c12209a8>] sctp_connect+0x31/0x4c
     [<c11d1e80>] inet_dgram_connect+0x4b/0x55
     [<c11834fa>] sys_connect+0x54/0x71
     [<c103a3a2>] ? lock_release_non_nested+0x88/0x239
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c11847ab>] sys_socketcall+0x6d/0x178
     [<c10da994>] ? trace_hardirqs_on_thunk+0xc/0x10
     [<c1002959>] syscall_call+0x7/0xb
    
    This was because the sctp_wait_for_connect() would aqcure the socket
    lock and then proceed to release the last reference count on the
    association, thus cause the fully destruction path to finish freeing
    the socket.
    
    The simplest solution is to start a very short timer in case the socket
    is owned by user.  When the timer expires, we can do some verification
    and be able to do the release properly.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9237ccbc0b22b5aa5396463ba0b14dc5efe5b98c
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Fri Sep 4 14:33:19 2009 +0800

    sctp: turn flags in 'struct sctp_association' into bit fields
    
    This shrinks the size of struct sctp_association a little.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

commit 02015180e2509afd2e3fe3790a333b30708a116b
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 8 14:19:01 2008 -0700

    sctp: shrink sctp_tsnmap some more by removing gabs array
    
    The gabs array in the sctp_tsnmap structure is only used
    in one place, sctp_make_sack().  As such, carrying the
    array around in the sctp_tsnmap and thus directly in
    the sctp_association is rather pointless since most
    of the time it's just taking up space.  Now, let
    sctp_make_sack create and populate it and then throw
    it away when it's done.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 8e1ee18c332e08bee9d8bd66e63cd564fbf17fc2
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 8 14:18:39 2008 -0700

    sctp: Rework the tsn map to use generic bitmap.
    
    The tsn map currently use is 4K large and is stuck inside
    the sctp_association structure making memory references REALLY
    expensive.  What we really need is at most 4K worth of bits
    so the biggest map we would have is 512 bytes.   Also, the
    map is only really usefull when we have gaps to store and
    report.  As such, starting with minimal map of say 32 TSNs (bits)
    should be enough for normal low-loss operations.  We can grow
    the map by some multiple of 32 along with some extra room any
    time we receive the TSN which would put us outside of the map
    boundry.  As we close gaps, we can shift the map to rebase
    it on the latest TSN we've seen.  This saves 4088 bytes per
    association just in the map alone along savings from the now
    unnecessary structure members.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f0fd56ed40ec5fb889bfc7efccd1c5759e6e9937
Author: Denis V. Lunev <den@openvz.org>
Date:   Mon Mar 3 11:55:54 2008 -0800

    [SCTP]: seq_printf format warning. (fixed)
    
    sctp_association->hbinterval is unsigned long. Replace %8d with %8lu.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e1857ea28dc76e2a929d1fff4d5d5cf712f12f4e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:25:32 2006 -0800

    [SCTP]: sctp_association ->peer.i is a host-endian analog of sctp_inthdr.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1e7d3d90c95b32374057e454417b2f50440be20e
Author: Vladislav Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Nov 11 16:06:16 2005 -0800

    [SCTP]: Remove timeouts[] array from sctp_endpoint.
    
    The socket level timeout values are maintained in sctp_sock and
    association level timeouts are in sctp_association. So there is
    no need for ep->timeouts.
    
    Signed-off-by: Vladislav Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
